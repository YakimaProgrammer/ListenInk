File: /Users/tarioyou/ListenInk/backend/src/types.ts
```
Content:
import { z } from "zod";

export const NaturalNumber = z.number().finite().min(0).multipleOf(1);
const id = z.string().nanoid();

export const DocIdSchema = z.object({
  document_id: id,
});
export type DocId = z.infer<typeof DocIdSchema>;

export const CategorySchema = z.object({
  userId: id,
  color: z.string(),
  name: z.string(),
  id: id,
  order: NaturalNumber
});
export type Category = z.infer<typeof CategorySchema>;

export const BookmarkSchema = z.object({
  id: id,
  page: NaturalNumber,
  audiotime: z.number().finite().min(0),
  documentId: id,
  order: NaturalNumber
});
export type Bookmark = z.infer<typeof BookmarkSchema>;

export const DocumentSchema = z.object({
  name: z.string(),
  numpages: NaturalNumber.min(1), // A document must have at least one page
  s3key: z.string(),
  bookmarks: z.array(BookmarkSchema), // I considered a .refine on the overall type to assert that no bookmark pointed beyond `numpages`, but then we couldn't use .partial() for DocumentSchema
  id: id,
  completed: z.boolean(),
  categoryId: id,
  order: NaturalNumber
})
export type Document = z.infer<typeof DocumentSchema>;

export const ErrSchema = z.object({
  err: z.string(),
});
export type Err = z.infer<typeof ErrSchema>;

export const UserSchema = z.object({
  name: z.string(),
  id: id,
  email: z.string().email()
});
export type User = z.infer<typeof UserSchema>;


```
File: /Users/tarioyou/ListenInk/backend/src/docs.ts
```
Content:
import { Router, Request, Response } from "express";
import { Bookmark, BookmarkSchema, DocId, Document, DocumentSchema, Err, NaturalNumber } from "./types";
import { PrismaClient, Prisma } from '@prisma/client';
import { Readable } from "stream";
import { APIError } from "./error";

const prisma = new PrismaClient();

async function maxDocOrder(tx: Prisma.TransactionClient, categoryId: string): Promise<number | null> {
  const result = await tx.document.aggregate({
    where: { categoryId },
    _max: { order: true },
  });
  return result._max.order;
}
async function maxBookmarkOrder(tx: Prisma.TransactionClient, documentId: string): Promise<number | null> {
  const result = await tx.bookmark.aggregate({
    where: { documentId },
    _max: { order: true },
  });
  return result._max.order;
}

// This router holds all of the /api/v1/docs routes.
// I'm using a router primarily to skip having to type
// all of that again and again.
export const router = Router();
router.post("/", (_req: Request, res: Response<DocId>) => { // `POST /api/v1/docs`
  res.status(200).send({"document_id": "c9663ed1fc2373ca8cb16ce8bcb4faae781ae8e1e1976803b7a756f81f309b60" });
});

router.get("/", async (req: Request, res: Response<Document[]>) => {
  const docs: Document[] = await prisma.document.findMany({
    where: {
      category: {
        userId: req.cookies.userId,
      },
    },
    include: {
      bookmarks: { orderBy: { order: "asc" } },
      category: true
    },
    orderBy: { order: "asc" }
  });

  res.status(200).send(docs);
});

router.get("/:docid/stream", (_req: Request, res: Response<string>) => { // `POST /api/v1/docs`
  res.status(200).send("todo...");
});

router.patch("/:docid", async (req: Request, res: Response<Document | Err>) => { // `PATCH /api/v1/docs/<docid>`
  try {
    const ret: Document = await prisma.$transaction(async (tx) => {
      const docId = req.params.docId;
      
      // Fetch the document along with its current category.
      const doc = await tx.document.findUnique({
	where: { id: docId },
	include: { category: true },
      });

      if (doc === null || doc.category.userId !== req.cookies.userId) {
	throw new APIError({err: "Not found!"});
      }

      // Parse the request from the user
      const partial = DocumentSchema.omit({ id: true, numpages: true, s3key: true, bookmarks: true, completed: true }).partial().safeParse(req.body);
      if (!partial.success) {
	throw new APIError({ err: partial.error.message });
      }
    
      const oldCategoryId = doc.categoryId;
      const newCategoryId = partial.data.categoryId;
      const oldOrder = doc.order;
      let newPosition;
      const movingToNewCategory = newCategoryId !== undefined && oldCategoryId !== newCategoryId;

      // Anonymous block
      {
	const res = NaturalNumber.safeParse(partial.data.order);
	if (res.success) {
	  newPosition = res.data;
	} else {
	  throw new APIError({err: "`order` must be a natural number!"});
	}
      };
      
      const { order: _, ...deltaData } = partial.data;
    
      if (movingToNewCategory) {
	const max = await maxDocOrder(tx, newCategoryId);
	if (max === null) {
	  throw new Error(`Unable to get the maximum order value for category ${newCategoryId}`);
	}
	// newPosition comes from partial.data.order which cannot be less than zero by the schema
	if (newPosition !== undefined && newPosition > max) {
	  throw new APIError({ err: "Tried to move a Document out of bounds!" });
	}
	
	// 1. In the old category, decrement order for all docs with order > oldOrder.
	await tx.document.updateMany({
          where: {
            categoryId: oldCategoryId,
            order: { gt: oldOrder },
          },
          data: { order: { decrement: 1 } },
	});
      
	// 2. In the new category, increment order for all docs with order >= newPosition.
	if (newPosition !== undefined) {
	  await tx.document.updateMany({
            where: {
              categoryId: newCategoryId,
              order: { gte: newPosition },
            },
            data: { order: { increment: 1 } },
	  });
	} else { 
	  newPosition = max;
	}
      
	// 3. Update the moving document to its new category and new order.
	return await tx.document.update({
          where: { id: docId },
          data: { categoryId: newCategoryId, order: newPosition, ...deltaData },
	  include: { bookmarks: true }
	});
      } else {
	// Moving within the same category.
	const max = await maxDocOrder(tx, oldCategoryId);
	if (max === null) {
	  throw new Error(`Unable to get the maximum order value for category ${oldCategoryId}`);
	}
	// newPosition comes from partial.data.order which cannot be less than zero by the schema
	if (newPosition !== undefined && newPosition > max) {
	  throw new APIError({ err: "Tried to move a Document out of bounds!" });
	}
	
	if (newPosition === undefined) {
	  newPosition = max;
	}

	if (newPosition < oldOrder) {
          // Moving up: Increment order for docs between newPosition and oldOrder (inclusive newPosition, exclusive oldOrder).
          await tx.document.updateMany({
            where: {
              categoryId: oldCategoryId,
              order: { gte: newPosition, lt: oldOrder },
            },
            data: { order: { increment: 1 } },
          });
	} else if (newPosition > oldOrder) {
          // Moving down: Decrement order for docs between oldOrder and newPosition (exclusive oldOrder, inclusive newPosition).
          await tx.document.updateMany({
            where: {
              categoryId: oldCategoryId,
              order: { gt: oldOrder, lte: newPosition },
            },
            data: { order: { decrement: 1 } },
          });
	} // else newPosition === oldOrder: do nothing 
      
	// Finally, update the moving document's order.
	return await tx.document.update({
          where: { id: docId },
          data: { order: newPosition, ...deltaData },
	  include: { bookmarks: true }
	});
      }
    });
    res.status(200).send(ret)
  } catch (e: unknown) {
    if (e instanceof APIError) {
      res.status(400).send(e.details);
    } else {
      res.status(500).send({err: "An unknown error occured!"});
    }
  }
});

router.patch("/:docid/bookmarks/:id", async (req: Request, res: Response<Bookmark | Err>) => {
  try {
    const bookmark: Bookmark = await prisma.$transaction(async (tx) => {
      const id = req.params.id;
      const docId = req.params.docid;
      let newOrder: number | undefined = undefined;

      const maxOrder = await maxBookmarkOrder(tx, docId);
      if (maxOrder === null) {
	throw new Error(`Unable to get the max order value for bookmark ${id}`);
      }
      
      const doc = await tx.document.findUnique({
	where: {
	  id: docId
	},
	include: {
	  bookmarks: true,
	  category: true
	}
      });
      if (doc === null || doc.category.userId !== req.cookies.userId) {
	throw new APIError({ err: "Not found!" });
      }
      const oldBookmark = doc.bookmarks.find(b => b.id === id);
      if (oldBookmark === undefined) {
	throw new APIError({ err: "Tried to update a Bookmark that does not exist!" });
      }
      
      const partial = BookmarkSchema.omit({ id: true, documentId: true }).partial().safeParse(req.body);
      if (!partial.success) {
	throw new APIError({ err: partial.error.message });
      }
      if (partial.data.page !== undefined) {
	if (partial.data.page > doc.numpages) {
	  throw new APIError({ err: "Cannot create a bookmark the points beyond the number of pages in the document!" });
	}
      }
      if (partial.data.order !== undefined) {
	if (partial.data.order > maxOrder) {
	  throw new APIError({ err: "Cannot move a bookmark out of bounds! " });
	}
	newOrder = partial.data.order;
      }

      if (newOrder !== undefined) {
	if (newOrder > oldBookmark.order) {
	  await tx.bookmark.updateMany({
	    where: {
	      documentId: docId,
	      order: { gt: oldBookmark.order, lte: newOrder }
	    },
	    data: { order: { decrement: 1 }}
	  });
	} else if (newOrder < oldBookmark.order) {
	  await tx.bookmark.updateMany({
	    where: {
	      documentId: docId,
	      order: { gte: newOrder, lt: oldBookmark.order }
	    },
	    data: { order: { increment: 1 }}
	  });
	}
      }

      const { order: _, ...deltaData } = partial.data;
      return await tx.bookmark.update({
	where: { id },
	data: { order: newOrder, ...deltaData }
      });
    });

    res.status(200).send(bookmark);
  } catch (e: unknown) {
    if (e instanceof APIError) {
      res.status(400).send(e.details);
    } else {
      console.error(e);
      res.status(500).send({ err: "An unknown error occured!" })
    }
  }
});

router.post("/:docid/bookmarks", async (req: Request, res: Response<Bookmark | Err>) => {
  try {
    const bookmark: Bookmark = await prisma.$transaction(async (tx) => {
      const docId = req.params.docid;
      const doc = await tx.document.findUnique({
	where: {
	  id: docId
	},
	include: {
	  bookmarks: true,
	  category: true
	}
      });
      if (doc === null || doc.category.userId !== req.cookies.userId) {
	throw new APIError({ err: "Not found!" });
      }
      const maxOrder = await maxBookmarkOrder(tx, docId);
      if (maxOrder === null) {
	throw new Error(`Unable to get the maximum order value for bookmarks associated with Document ${docId}`);
      }
      const partial = BookmarkSchema.omit({ id: true, documentId: true }).partial({ order: true }).safeParse(req.body);
      if (!partial.success) {
	throw new APIError({ err: partial.error.message });
      }
      if (partial.data.order !== undefined) {
	if (partial.data.order > maxOrder + 1) {
	  throw new APIError({ err: "Cannot create a bookmark out of bounds! "});
	}
	if (partial.data.order < maxOrder + 1) {
	  await tx.bookmark.updateMany({
	    where: {
	      documentId: docId,
	      order: { gte: partial.data.order }
	    },
	    data: { order: { increment: 1 }}
	  });
	}
      }
      
      return await tx.bookmark.create({
	data: {
	  ...partial.data,
	  order: partial.data.order ?? (maxOrder + 1),
	  documentId: docId
	}
      });
    });

    res.status(200).send(bookmark);
  } catch (e: unknown) {
    if (e instanceof APIError) {
      res.status(400).send(e.details);
    } else {
      res.status(500).send({ err: "An unexpected error occured!" });
    }
  }
});

router.delete("/:docid/bookmarks/:id", async (req: Request, res: Response<Err | undefined>) => {
  try {
    await prisma.$transaction(async (tx) => {
      const docId = req.params.docid;
      const id = req.params.id;
      const doc = await tx.document.findUnique({
	where: {
	  id: docId
	},
	include: {
	  bookmarks: true,
	  category: true
	}
      });
      if (doc === null || doc.category.userId !== req.cookies.userId) {
	throw new APIError({ err: "Not found!" });
      }
      const oldBookmark = doc.bookmarks.find(b => b.id === id);
      if (oldBookmark === undefined) {
	throw new APIError({ err: `No such bookmark with id ${id} exists on document ${docId}!`});
      }
      await tx.bookmark.delete({
	where: { id }
      });
      await tx.bookmark.updateMany({
	where: {
	  documentId: docId,
	  order: { gt: oldBookmark.order }
	},
	data: { order: { decrement: 1 } }
      });
    });

    res.status(204).send();
  } catch (e: unknown) {
    if (e instanceof APIError) {
      res.status(400).send(e.details);
    } else {
      res.status(500).send({ err: "An unexpected error occured!" });
    }
  }
});

router.delete("/:docid", async (req: Request, res: Response<Document | Err>) => {
  try {
    await prisma.$transaction(async (tx) => {
      const docId = req.params.docid;
      const doc = await tx.document.findUnique({
	where: {
	  id: docId
	},
	include: {
	  bookmarks: true,
	  category: true
	}
      });
      if (doc === null || doc.category.userId !== req.cookies.userId) {
	throw new APIError({ err: "Not found!" });
      }
      await tx.document.delete({
	where: { id: docId }
      });
      await tx.document.updateMany({
	where: {
	  id: docId,
	  order: { gt: doc.order }
	},
	data: { order: { decrement: 1 } }
      });
    });

    res.status(204).send();
  } catch (e: unknown) {
    if (e instanceof APIError) {
      res.status(400).send(e.details);
    } else {
      res.status(500).send({ err: "An unexpected error occured!" });
    }
  }
});

router.get("/:docid", async (req: Request, res: Response<Document | Err>) => { // `GET /api/v1/docs/<id>`
  const doc = await prisma.document.findUnique({
    where: {
      id: req.params.docid
    },
    include: {
      bookmarks: { orderBy: { order: "asc" } },
      category: true
    }
  });

  if (doc === null || doc.category.userId !== req.cookies.userId) {
    res.status(404).send({err: "Not found!"});
  } else {
    res.status(200).send(doc);
  }
});

// `GET /api/v1/docs/<docid>/pages/<pagenum>/image`
// for example: `http://localhost:8080/api/v1/docs/48723/pages/0/image`
router.get("/:docid/pages/:pagenum/image", async (req: Request, res: Response) => {
  const doc = await prisma.document.findUnique({
    where: {
      id: req.params.docid
    },
    include: {
      category: true
    }
  });

  if (doc === null || doc.category.userId !== req.cookies.userId) {
    res.status(404).send({err: "Not found!"});
  } else {
    const response = await fetch(`https://s3.magnusfulton.com/com.listenink/${doc.s3key}/${req.params.pagenum}.jpg`);
    res.setHeader('Content-Type', response.headers.get('content-type') ?? "image/jpeg");
    res.status(200);
    if (response.body === null) {
      res.send();
    } else {
      Readable.fromWeb(response.body).pipe(res);
    }
  }
});

router.get("/:docid/pages/:pagenum/audio", async (req: Request, res: Response) => {
  const doc = await prisma.document.findUnique({
    where: {
      id: req.params.docid
    },
    include: {
      category: true
    }
  });

  if (doc === null || doc.category.userId !== req.cookies.userId) {
    res.status(404).send({err: "Not found!"});
  } else {
    const response = await fetch(`https://s3.magnusfulton.com/com.listenink/${doc.s3key}/${req.params.pagenum}.mp3`);
    res.setHeader('Content-Type', response.headers.get('content-type') ?? "audio/mpeg");
    res.status(200);
    if (response.body === null) {
      res.send();
    } else {
      Readable.fromWeb(response.body).pipe(res);
    }
  }
});

router.get("/:docid/pages/:pagenum/text", async (req: Request, res: Response) => {
  const doc = await prisma.document.findUnique({
    where: {
      id: req.params.docid
    },
    include: {
      category: true
    }
  });

  if (doc === null || doc.category.userId !== req.cookies.userId) {
    res.status(404).send({err: "Not found!"});
  } else {
    const response = await fetch(`https://s3.magnusfulton.com/com.listenink/${doc.s3key}/${req.params.pagenum}.hocr`);
    res.setHeader('Content-Type', response.headers.get('content-type') ?? "text/vnd.hocr+html");
    res.status(200);
    if (response.body === null) {
      res.send();
    } else {
      Readable.fromWeb(response.body).pipe(res);
    }
  }
});



```
File: /Users/tarioyou/ListenInk/backend/src/categories.ts
```
Content:
import { Router, Request, Response } from "express";
import { PrismaClient, Prisma } from '@prisma/client';
import { Category, CategorySchema, Err } from "./types";
import { APIError } from "./error";

const prisma = new PrismaClient();

async function maxCategoryOrder(tx: Prisma.TransactionClient, userId: string): Promise<number | null> {
  const result = await tx.category.aggregate({
    where: { userId },
    _max: { order: true },
  });
  return result._max.order;
}


export const router = Router();
router.get("/", async (req: Request, res: Response<Category[]>) => {
  const categories: Category[] = await prisma.category.findMany({
    where: {
      userId: req.cookies.userId,
    },
    orderBy: { order: "asc" }
  });
  
  res.status(200).send(categories);
});

router.post("/", async (req: Request, res: Response<Category | Err>) => {
  try {
    const category: Category = await prisma.$transaction(async (tx) => {
      const userId = req.cookies.userId;
      const maxOrder = await maxCategoryOrder(tx, userId);
      if (maxOrder === null) {
	throw new Error(`Unable to get the maximum order value for user ${userId}`);
      }
      const partial = CategorySchema.omit({ id: true, userId: true }).partial({ order: true }).safeParse(req.body);
      if (!partial.success) {
	throw new APIError({ err: partial.error.message });
      }
      const newOrder = partial.data.order;
      if (newOrder !== undefined) {
	// +1 because the user could be *very* explicit about wanting to append
	if (newOrder > maxOrder + 1) {
	  throw new APIError({ err: "Tried to create a new category out of bounds!" });
	}

	await tx.category.updateMany({
	  where: { userId, order: { gte: newOrder }},
	  data: { order: { increment: 1 }}
	});
      }

      return await tx.category.create({
	data: {
	  ...partial.data,
	  userId,
	  order: newOrder ?? (maxOrder + 1)
	}
      });
    });

    res.status(200).send(category);
  } catch (e: unknown) {
    if (e instanceof APIError) {
      res.status(400).send(e.details);
    } else {
      res.status(500).send({ err: "An unknown error occured!" });
    }
  }
});

router.patch("/:catid", async (req: Request, res: Response<Category | Err>) => {
  try {
    const category: Category = await prisma.$transaction(async (tx) => {
      const userId = req.cookies.userId;
      const id = req.params.catid;
      const category = await prisma.category.findUnique({ where: { id } });
      if (category === null || category.userId !== userId) {
	throw new APIError({ err: "Not found!" });
      }
      const partial = CategorySchema.omit({ id: true, userId: true }).partial().safeParse(req.body);
      if (!partial.success) {
	throw new APIError({ err: partial.error.message });
      }
      const newOrder = partial.data.order;
      const oldOrder = category.order;
      if (newOrder !== undefined) {
	const maxOrder = await maxCategoryOrder(tx, userId);
	if (maxOrder === null) {
	  throw new Error(`Unable to get the maximum order value for user ${userId}`);
	}
	if (newOrder > maxOrder) {
	  throw new APIError({ err: "Cannot move a category out of bounds!" });
	}
	if (newOrder > oldOrder) {
	  await tx.category.updateMany({
	    where: { userId, order: { gt: oldOrder, lte: newOrder } },
	    data: { order: { decrement: 1} }
	  });
	} else if (newOrder < oldOrder) {
	  await tx.category.updateMany({
	    where: { userId, order: { lt: oldOrder, gte: newOrder } },
	    data: { order: { increment: 1} }
	  });
	} // else newOrder === oldOrder: do nothing 
      }
      return await tx.category.update({
	where: { id },
	data: partial.data
      });
    });

    res.status(200).send(category);
  } catch (e: unknown) {
    if (e instanceof APIError) {
      res.status(400).send(e.details);
    } else {
      res.status(500).send({ err: "An unknown error occured!" });
    }
  }
});

router.delete("/:catid", async (req: Request, res: Response<Err>) => {
  try {
    await prisma.$transaction(async (tx) => {
      const id = req.params.catid;
      const userId = req.cookies.userId;
      const category = await tx.category.findUnique({ where: { id } });
      if (category === null || category.userId !== userId) {
	throw new APIError({ err: "Not found!" });
      }
      await tx.category.updateMany({
	where: { userId, order: { gt: category.order } },
	data: { order: { decrement: 1 } }
      });
      await tx.category.delete({
	where: { id }
      });
    });
    res.status(204).send();
  } catch (e: unknown) {
    if (e instanceof APIError) {
      res.status(400).send(e.details);
    } else {
      res.status(500).send({ err: "An unknown error occured!" });
    }
  }
});


```
File: /Users/tarioyou/ListenInk/backend/src/index.ts
```
Content:
import express, { Express, Router } from "express";
import cookieParser from "cookie-parser";
import { router as docs } from "./docs";
import { router as auth } from "./auth";
import { router as category } from "./categories";

// Register all the sub-API endpoints: /docs, /category, etc.
const api = Router();
api.use("/docs", docs);
api.use("/auth", auth);
api.use("/categories", category);

// Register the api endpoints with the app
const app: Express = express();
app.use(express.json());
app.use(cookieParser());
app.use("/api/v1", api);

// Serve the app
const port = 8080;
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});


```
File: /Users/tarioyou/ListenInk/backend/src/error.ts
```
Content:
import { Err } from "./types";

/** Represents a 400/user error with the API. Pairs nicely with prisma.$transaction. Use Error for an internal server error. */
export class APIError extends Error {
  details: Err
  constructor(reason: Err) {
    super(reason.err);
    this.details = reason;
    Object.setPrototypeOf(this, APIError.prototype);
  }
}


```
File: /Users/tarioyou/ListenInk/backend/src/auth.ts
```
Content:
import { Router, Request, Response } from "express";
import { PrismaClient } from '@prisma/client';
import { Err, User } from "./types";

const prisma = new PrismaClient();

export const router = Router();

router.post("/", async (_req: Request, res: Response<User>) => {
  const users: User[] = await prisma.user.findMany();
  const user = users[Math.floor(Math.random() * users.length)];
  
  res.status(200).cookie("userId", user.id).send(user);
});

router.get("/", async (req: Request, res: Response<User | Err>) => {
  const user = await prisma.user.findUnique({ where: { id: req.cookies.userId }});
  if (user === null) {
    res.status(404).send({err: "Not found!"})
  } else {
    res.status(200).send(user);
  }
});


```
