File: /Users/tarioyou/ListenInk/frontend/hi.txt
Content:```
.
|____chat_context.txt
|____hi.txt
|____chat_context.py
|____public
| |____favicon.ico
| |____index.html
| |____logo512.png
| |____manifest.json
| |____robots.txt
| |____logo192.png
|____.gitignore
|____package-lock.json
|____package.json
|____config-overrides.js
|____tsconfig.json
|____src
| |____index.tsx
| |____index.css
| |____types.ts
| |____styles
| | |_____drawer.scss
| |____components
| | |____SearchDialog
| | | |____index.tsx
| | | |____index.module.scss
| | |____Conditional
| | | |____index.tsx
| | | |____index.module.scss
| | |____PDFViewer
| | | |____index.tsx
| | | |____PdfTopView.tsx
| | | |____PdfViewer.module.scss
| | | |____PdfViewer.tsx
| | | |____index.module.scss
| | |____WithDocument
| | | |____index.tsx
| | |____DrawerHeader
| | | |____index.tsx
| | | |____index.module.scss
| | |____AudioControls
| | | |____index.tsx
| | | |____index.module.scss
| |____react-app-env.d.ts
| |____pages
| | |____Auth
| | | |____index.tsx
| | |____urlfor.tsx
| | |____Root
| | | |____Sidebar
| | | | |____index.tsx
| | | | |____index.module.scss
| | | |____index.tsx
| | | |____MenuBar
| | | | |____index.tsx
| | | | |____index.module.scss
| | | |____Content
| | | | |____index.tsx
| | | | |____index.module.scss
| | | |____index.module.scss
| | | |____Categories
| | | | |____index.tsx
| |____store
| | |____helper-types.ts
| | |____slices
| | | |____categories.ts
| | | |____ui.ts
| | | |____auth.ts
| | |____thunks.ts
| | |____index.ts


```
File: /Users/tarioyou/ListenInk/frontend/package.json
Content:```
{
  "name": "ListenInk Frontend",
  "version": "0.1.0",
  "private": true,
  "proxy": "http://localhost:8080",
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^6.4.2",
    "@mui/material": "^6.4.2",
    "@reduxjs/toolkit": "^2.5.0",
    "bootstrap-icons": "^1.11.3",
    "cra-template-typescript": "1.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-redux": "^9.2.0",
    "react-router": "^7.1.1",
    "react-scripts": "5.0.1",
    "sass": "^1.83.4",
    "zod": "^3.24.1"
  },
  "scripts": {
    "start": "react-app-rewired start",
    "build": "react-app-rewired build",
    "test": "react-app-rewired test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11",
    "@types/react": "^19.0.6",
    "@types/react-dom": "^19.0.3",
    "react-app-rewire-alias": "^1.1.7",
    "react-app-rewired": "^2.2.1"
  }
}


```
File: /Users/tarioyou/ListenInk/frontend/config-overrides.js
Content:```
const { alias } = require("react-app-rewire-alias");

module.exports = function override(config) {
  alias({
    "@": "src",
  })(config);

  return config;
};


```
File: /Users/tarioyou/ListenInk/frontend/tsconfig.json
Content:```
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*":["./src/*"]
     }
  },
  "include": [
    "src"
  ]
}


```
File: /Users/tarioyou/ListenInk/frontend/public/favicon.ico
Content:```
Could not read file /Users/tarioyou/ListenInk/frontend/public/favicon.ico due to: 'utf-8' codec can't decode byte 0xe3 in position 14: invalid continuation byte

```
File: /Users/tarioyou/ListenInk/frontend/public/index.html
Content:```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>


```
File: /Users/tarioyou/ListenInk/frontend/public/logo512.png
Content:```
Could not read file /Users/tarioyou/ListenInk/frontend/public/logo512.png due to: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte

```
File: /Users/tarioyou/ListenInk/frontend/public/manifest.json
Content:```
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}


```
File: /Users/tarioyou/ListenInk/frontend/public/robots.txt
Content:```
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:


```
File: /Users/tarioyou/ListenInk/frontend/public/logo192.png
Content:```
Could not read file /Users/tarioyou/ListenInk/frontend/public/logo192.png due to: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte

```
File: /Users/tarioyou/ListenInk/frontend/src/index.tsx
Content:```
import React from "react";
import ReactDOM from "react-dom/client";
import { createBrowserRouter, RouterProvider } from "react-router";
import { StyledEngineProvider } from "@mui/material/styles";
import { Provider } from "react-redux";
import { store } from "./store";
import { urlFor } from "./pages/urlfor";

// Components
import { Root } from "./pages/Root";
import { Auth } from "./pages/Auth";

// A global css file, but we use css modules for this project for namespacing
import "./index.css";
import "bootstrap-icons/font/bootstrap-icons.css";

let router = createBrowserRouter([
  {
    path: "/",
    Component: Root,
  },
  {
    path: urlFor("docs", ":docId"),
    Component: Root
  },
  {
    path: "/auth",
    Component: Auth,
  },
]);

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <StyledEngineProvider injectFirst>
      <Provider store={store}>
	<RouterProvider router={router} />
      </Provider>
    </StyledEngineProvider>
  </React.StrictMode>
);


```
File: /Users/tarioyou/ListenInk/frontend/src/index.css
Content:```
html, body {
    margin: 0;
    padding: 0;
    background-color: #121212;
    color: white;
    font-family: 'Roboto', 'Segoe UI', 'Helvetica Neue', sans-serif;
    height: 100%;
  }
  
  #root {
    height: 100%;
  }
  
  /* Add styling for MUI components globally */
  .MuiButton-contained {
    background: linear-gradient(135deg, #6c63ff, #5046e5) !important;
    box-shadow: 0 4px 10px rgba(108, 99, 255, 0.3) !important;
    transition: all 0.3s ease !important;
  }
  
  .MuiButton-contained:hover {
    transform: translateY(-2px) !important;
    box-shadow: 0 6px 12px rgba(108, 99, 255, 0.4) !important;
  }
  
  .MuiPaper-root {
    background-color: #1a1a2e !important;
    color: white !important;
  }
  
  .MuiMenuItem-root {
    color: rgba(255, 255, 255, 0.85) !important;
  }
  
  .MuiMenuItem-root:hover {
    background-color: rgba(255, 255, 255, 0.05) !important;
  }
  
  .MuiListItemButton-root.Mui-selected {
    background-color: rgba(108, 99, 255, 0.15) !important;
  }

```
File: /Users/tarioyou/ListenInk/frontend/src/types.ts
Content:```
import { z } from "zod";

export const NaturalNumber = z.number().finite().min(0).multipleOf(1);
const id = z.string().nanoid();

export const DocIdSchema = z.object({
  document_id: id,
});
export type DocId = z.infer<typeof DocIdSchema>;

export const CategorySchema = z.object({
  userId: id,
  color: z.string(),
  name: z.string(),
  id: id,
  order: NaturalNumber
});
export type Category = z.infer<typeof CategorySchema>;

export const BookmarkSchema = z.object({
  id: id,
  page: NaturalNumber,
  audiotime: z.number().finite().min(0),
  documentId: id,
  order: NaturalNumber
});
export type Bookmark = z.infer<typeof BookmarkSchema>;

export const DocumentSchema = z.object({
  name: z.string(),
  numpages: NaturalNumber.min(1), // A document must have at least one page
  s3key: z.string(),
  bookmarks: z.array(BookmarkSchema), // I considered a .refine on the overall type to assert that no bookmark pointed beyond `numpages`, but then we couldn't use .partial() for DocumentSchema
  id: id,
  completed: z.boolean(),
  categoryId: id,
  order: NaturalNumber
})
export type Document = z.infer<typeof DocumentSchema>;

export const ErrSchema = z.object({
  err: z.string(),
});
export type Err = z.infer<typeof ErrSchema>;

export const UserSchema = z.object({
  name: z.string(),
  id: id,
  email: z.string().email()
});
export type User = z.infer<typeof UserSchema>;


```
File: /Users/tarioyou/ListenInk/frontend/src/react-app-env.d.ts
Content:```
/// <reference types="node" />
/// <reference types="react" />
/// <reference types="react-dom" />

declare namespace NodeJS {
  interface ProcessEnv {
    readonly NODE_ENV: 'development' | 'production' | 'test';
    readonly PUBLIC_URL: string;
  }
}

declare module '*.avif' {
  const src: string;
  export default src;
}

declare module '*.bmp' {
  const src: string;
  export default src;
}

declare module '*.gif' {
  const src: string;
  export default src;
}

declare module '*.jpg' {
  const src: string;
  export default src;
}

declare module '*.jpeg' {
  const src: string;
  export default src;
}

declare module '*.png' {
  const src: string;
  export default src;
}

declare module '*.webp' {
    const src: string;
    export default src;
}

declare module '*.svg' {
  import * as React from 'react';

  export const ReactComponent: React.FunctionComponent<React.SVGProps<
    SVGSVGElement
  > & { title?: string }>;

  const src: string;
  export default src;
}

declare module '*.module.css' {
  const classes: { readonly [key: string]: string };
  export default classes;
}

declare module '*.module.scss' {
  const classes: { readonly [key: string]: string };
  export default classes;
}

declare module '*.module.sass' {
  const classes: { readonly [key: string]: string };
  export default classes;
}

declare module '*.txt' {
  const content: string;
  export default content;
}

declare module '*.pdf' {
  const src: string;
  export default src;
}


```
File: /Users/tarioyou/ListenInk/frontend/src/styles/_drawer.scss
Content:```
$drawer-width: 240px;
$drawer-height: 64px;


```
File: /Users/tarioyou/ListenInk/frontend/src/components/SearchDialog/index.tsx
Content:```
// --- frontend/src/components/SearchDialog/index.tsx ---
import { AppDispatch, RootState, setQuery, setSearchDialog } from "@/store";
import {
  Dialog,
  DialogContent,
  IconButton,
  InputAdornment,
  List,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  TextField,
  Typography,
} from "@mui/material";
import { connect, ConnectedProps } from "react-redux";
import { useNavigate } from "react-router";
import { JSX } from "react";
import { Search, Close, Description } from "@mui/icons-material";
import { urlFor } from "@/pages/urlfor";
import { EnhancedDocument } from "@/store/slices/categories";
import { Document } from "@/types";

import style from "./index.module.scss";

const mapStateToProps = (state: RootState) => ({
  query: state.ui.searchQuery,
  open: state.ui.searchDialogOpen,
  docs:
    state.categories.status === "success"
      ? Object.values(state.categories.documents).filter(
          (d): d is EnhancedDocument => d !== undefined
        )
      : [],
});

const mapDispatchToProps = (dispatch: AppDispatch) => ({
  close: () => dispatch(setSearchDialog(false)),
  setQuery: (query: string) => dispatch(setQuery(query)),
});
const connector = connect(mapStateToProps, mapDispatchToProps);
type PropsFromRedux = ConnectedProps<typeof connector>;

const NUM_RESULTS = 10;

function SearchDialogComponent({
  query,
  open,
  close,
  setQuery,
  docs,
}: PropsFromRedux) {
  const navigate = useNavigate();

  // Add doc.text search
  const hits = docs
    .filter((d: EnhancedDocument) => {
      const titleMatch = d.name.toLowerCase().includes(query.toLowerCase());
      // @TODO
      const textMatch = true; // d.text?.toLowerCase().includes(query.toLowerCase()) ?? false;
      return titleMatch || textMatch;
    })
    .slice(0, NUM_RESULTS);

  const results: JSX.Element[] = [];
  for (let i = 0; i < NUM_RESULTS; i++) {
    let d: Document | undefined = hits[i];
    results.push(
      <ListItemButton
        key={i}
        onClick={() => {
          if (d) {
            navigate(urlFor("docs", d.id));
            close();
          }
        }}
        className={!d ? style.hidden : ""}
      >
        <ListItemIcon>
          <Description style={{ color: "white" }} />
        </ListItemIcon>
        {d?.name}
      </ListItemButton>
    );
  }

  return (
    <Dialog
      open={open}
      onClose={close}
      maxWidth="sm"
      fullWidth
      PaperProps={{ className: style.searchDialog }}
    >
      <DialogContent dividers className={style.searchDialogContent}>
        <TextField
          variant="standard"
          placeholder="Search documents..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          fullWidth
          className={style.searchInput}
          slotProps={{
            input: {
              startAdornment: (
                <InputAdornment position="start">
                  <Search />
                </InputAdornment>
              ),
              endAdornment: (
                <InputAdornment position="end">
                  <IconButton
                    onClick={query === "" ? close : () => setQuery("")}
                    size="small"
                  >
                    <Close />
                  </IconButton>
                </InputAdornment>
              ),
            },
          }}
        />
        <List className={style.resultsList}>
          {hits.map((doc, i) => (
            <ListItemButton
              key={i}
              onClick={() => {
                if (doc) {
                  navigate(urlFor("docs", doc.id));
                  close();
                }
              }}
              className={!doc ? style.hidden : style.resultItem}
            >
              <ListItemIcon>
                <Description style={{ color: "white" }} />
              </ListItemIcon>
              <ListItemText primary={doc?.name} />
            </ListItemButton>
          ))}
        </List>

        {query && hits.length === 0 && (
          <Typography
            variant="body2"
            textAlign="center"
            mt={2}
            className={style.noResults}
          >
            No documents found
          </Typography>
        )}
      </DialogContent>
    </Dialog>
  );
}

export const SearchDialog = connector(SearchDialogComponent);


```
File: /Users/tarioyou/ListenInk/frontend/src/components/SearchDialog/index.module.scss
Content:```
.hidden {
    opacity: 0;
}

// Add these new styles
.searchDialog {
  background-color: rgba(26, 26, 46, 0.95);
  border-radius: 16px;
  backdrop-filter: blur(15px);
}

.searchInput {
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  color: white;
  padding: 10px 15px;
  margin-bottom: 15px;
  
  input {
    color: white;
  }
  
  svg {
    color: rgba(255, 255, 255, 0.7);
  }
}

.resultsList {
  padding: 0;
}

.resultItem {
  border-radius: 8px;
  margin: 4px 0;
  transition: all 0.2s ease;
  
  &:hover {
    background-color: rgba(255, 255, 255, 0.1);
    transform: translateX(2px);
  }
}

.noResults {
  color: rgba(255, 255, 255, 0.7);
  margin-top: 20px;
}

.searchDialogContent {
    padding-right: 24px !important;
    padding-left: 24px !important;
    overflow-x: hidden;
  }
  
  .resultsList {
    width: 100%;
    overflow-x: hidden;
  }

```
File: /Users/tarioyou/ListenInk/frontend/src/components/Conditional/index.tsx
Content:```
import { ReactNode } from 'react';
import { Box, CircularProgress, Typography, Icon } from "@mui/material";
import { WarningAmber } from "@mui/icons-material";
import { LoadingState } from '@/store/helper-types';

import styles from "./index.module.scss";

interface ConditionalProps {
  status: LoadingState;
  reason?: string;
  children?: ReactNode;
}

export function Conditional({ status, reason, children }: ConditionalProps) {
  switch (status) {
    case "success":
      return <>{ children }</>;

    case "pending":
      return (
        <Box className={styles.box}>
          <CircularProgress />
	</Box>
      );

    case "failure":
      return (
        <Box className={styles.box}>
          <Icon color="error">
	    <WarningAmber />
	  </Icon>
	  <Typography>{reason}</Typography>
	</Box>
      );
  }
}


```
File: /Users/tarioyou/ListenInk/frontend/src/components/Conditional/index.module.scss
Content:```
.box {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100%;
    flex-direction: column;
}


```
File: /Users/tarioyou/ListenInk/frontend/src/components/PDFDropModal/index.tsx
Content:```
// --- frontend/src/components/PDFDropModal/index.tsx ---
import { DragEvent } from "react";
import { Dialog, Box, Typography } from "@mui/material";
import { connect, ConnectedProps } from "react-redux";
import {
  RootState,
  AppDispatch,
  updateDocument,
  setPdfDropModal,
  setPdfDropStatus,
  PDFDropStatus,
  createDocument,
} from "@/store";
import { createSelector } from "@reduxjs/toolkit";
import { useNavigate } from "react-router";
import { urlFor } from "@/pages/urlfor";
import styles from "./index.module.scss";
import { Upload, Check, Error, CloudUpload } from "@mui/icons-material";

const selectDocuments = (state: RootState) => {
  if (state.categories.status === "success") {
    return state.categories.documents;
  } else {
    return {};
  }
};
const selectByName = createSelector(
  [selectDocuments, (_state: RootState, name: string) => name],
  (documents, name) => Object.values(documents).find((d) => d?.name === name)
);

const mapState = (state: RootState) => ({
  isOpen: state.ui.pdfDropModalOpen,
  status: state.ui.pdfDropModalStatus,
  // This is not great Redux style
  findByName: (name: string) => selectByName(state, name),
});

const mapDispatch = (dispatch: AppDispatch) => ({
  close: () => {
    dispatch(setPdfDropModal(false));
    dispatch(setPdfDropStatus("neutral"));
  },
  renameDoc: (docId: string, name: string) =>
    dispatch(updateDocument({ docId, name })),
  setStatus: (status: PDFDropStatus) => dispatch(setPdfDropStatus(status)),
  createDoc: (file: File) => dispatch(createDocument({ file })),
});
const connector = connect(mapState, mapDispatch);
type PropsFromRedux = ConnectedProps<typeof connector>;

function PDFDropModal({
  isOpen,
  close,
  status,
  setStatus,
  createDoc,
}: PropsFromRedux) {
  const navigate = useNavigate();

  const handleDragOver = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    setStatus("hover");
  };
  const handleDragExit = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    setStatus("neutral");
  };
  const handleDrop = async (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file === undefined || file.type !== "application/pdf") {
      setStatus("drop-failure");
      return;
    }
    const doc = await createDoc(file);
    if (typeof doc.payload === "string" || doc.payload === undefined) {
      setStatus("drop-failure");
    } else {
      navigate(urlFor("docs", doc.payload.id));
      close();
    }
  };

  let typography;
  let style;
  switch (status) {
    case "hover":
      style = { bgcolor: "primary.light", color: "primary.contrastText" };
      typography = (
        <Typography variant="body1">What will you learn today?</Typography>
      );
      break;

    case "neutral":
      style = { bgcolor: "grey.200", color: "text.primary" };
      typography = (
        <Typography variant="body1">Drop here to create a new doc.</Typography>
      );
      break;

    case "drop-success":
      style = { bgcolor: "primary.light", color: "primary.contrastText" };
      typography = <Typography variant="body1">Let's read!</Typography>;
      break;

    case "drop-failure":
      style = { bgcolor: "error.light", color: "error.dark" };
      typography = (
        <Typography variant="body1">
          Only PDF files are supported at this time!
        </Typography>
      );
      break;
  }

  return (
    <Dialog
      open={isOpen}
      onClose={close}
      maxWidth="xl"
      fullWidth
      PaperProps={{ className: styles.modalContent }}
    >
      <Box
        onDragExit={handleDragExit}
        onDragOver={handleDragOver}
        onDrop={handleDrop}
        className={`${styles.dropArea} ${styles[status]}`}
      >
        {/* Replace the Typography with this */}
        <Typography variant="body1" className={styles.dropText}>
          {status === "neutral" && (
            <>
              <CloudUpload fontSize="large" />
              Drop here to create a new doc.
            </>
          )}
          {status === "hover" && (
            <>
              <Upload fontSize="large" />
              What will you learn today?
            </>
          )}
          {status === "drop-success" && (
            <>
              <Check fontSize="large" />
              Let's read!
            </>
          )}
          {status === "drop-failure" && (
            <>
              <Error fontSize="large" />
              Only PDF files are supported at this time!
            </>
          )}
        </Typography>
      </Box>
    </Dialog>
  );
}

export default connector(PDFDropModal);


```
File: /Users/tarioyou/ListenInk/frontend/src/components/PDFDropModal/index.module.scss
Content:```
.modalContent {
    border-radius: 16px;
    overflow: hidden;
  }
  
  .dropArea {
    min-height: 300px;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: all 0.3s ease;
    
    &.neutral {
      background: linear-gradient(135deg, #1a1a2e, #252542);
      color: rgba(255, 255, 255, 0.9);
    }
    
    &.hover {
      background: linear-gradient(135deg, #4b6cb7, #182848);
      color: white;
    }
    
    &.success {
      background: linear-gradient(135deg, #2e7d32, #1b5e20);
      color: white;
    }
    
    &.failure {
      background: linear-gradient(135deg, #c62828, #b71c1c);
      color: white;
    }
    
    .dropText {
      font-size: 1.2rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      
      svg {
        margin-right: 10px;
      }
    }
  }

```
File: /Users/tarioyou/ListenInk/frontend/src/components/PDFViewer/index.tsx
Content:```
import { connect, ConnectedProps } from "react-redux";
import { AppDispatch, setSearchDialog, upsertBookmark } from "@/store";

import { withDocument, InjectedProps } from "../WithDocument";
import { PdfViewer } from "./PdfViewer";
import styles from "./index.module.scss";

const mapDispatchToProps = (
  dispatch: AppDispatch,
  ownProps: InjectedProps
) => ({
  openSearchDialog: () => dispatch(setSearchDialog(true)),
  //I'm going to say that the playback time should be inferred to be set to the start if you change pages imo
  setPage: (page: number) =>
    dispatch(upsertBookmark({ docId: ownProps.docId, page, time: 0 })),
});

const connector = connect(null, mapDispatchToProps);
type PropsFromRedux = ConnectedProps<typeof connector> & InjectedProps;

function PDFViewerComponent({
  openSearchDialog,
  doc,
  setPage,
  docId,
}: PropsFromRedux) {
  const page = doc.bookmarks.at(0)?.page ?? 0;

  return (
    <div className={styles.mainPdf}>
      <PdfViewer
        scale={1}
        docId={docId}
        totalPages={doc.numpages}
        currentPage={page}
        onPageChange={setPage}
      />
    </div>
  );
}

export const PDFViewer = withDocument(connector(PDFViewerComponent));


```
File: /Users/tarioyou/ListenInk/frontend/src/components/PDFViewer/PdfTopView.tsx
Content:```
// Import necessary components and modules from MUI library.
import {
  Search,
  KeyboardArrowUp,
  KeyboardArrowDown,
  ZoomIn,
  ZoomOut,
} from "@mui/icons-material";
import { Box, IconButton, TextField } from "@mui/material";
import { useEffect, useState } from "react";

// Import styles (CSS) from other scss files.
// import styles from "./PdfViewer.module.scss";
import styles from "./pdfTopBar.module.scss";

interface PdfTopViewProps {
  currentPage: number;
  totalPages: number;
  zoomLevel: number;
  onPageChange: (page: number) => void;
  onZoomChange: (zoom: number) => void;
  openSearchDialog: () => void;
}

export function PdfTopView({
  currentPage,
  totalPages,
  zoomLevel,
  onPageChange,
  onZoomChange,
  openSearchDialog,
}: PdfTopViewProps) {
  // Holding users to the strict input validation requirements sucks.
  // Let's transiently let them break those requirements
  const [transientPage, setTransientPage] = useState(`${currentPage}`);
  const [isValid, setIsValid] = useState(true);

  // Reset transientPage when the external page changes. We trust this value
  useEffect(() => {
    setTransientPage(`${currentPage}`);
    setIsValid(true);
  }, [currentPage]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newPage = parseFloat(e.target.value);

    // Update transient value immediately
    setTransientPage(e.target.value);

    // A page must be between zero and the maximum number of pages and must be an integer
    if (
      newPage >= 0 &&
      newPage <= totalPages &&
      newPage === Math.floor(newPage)
    ) {
      onPageChange(newPage);
      setIsValid(true);
    } else {
      setIsValid(false);
    }
  };

  return (
    <div>
      {/* Entire Top Bar Section */}
      {/* Box for the top bar */}
      <Box
        sx={{
          width: 1040,
          height: 40,
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "flex-start",
        }}
        className={styles.pdfTopBar}
      >
        {/* Search Icon for searching content */}
        <IconButton className={styles.searchIcon} onClick={openSearchDialog}>
          <Search />
        </IconButton>

        {/* Page Number Display Section */}
        <div className={styles.pageNumberDisplayBox}>
          <IconButton onClick={() => onPageChange(currentPage + 1)}>
            <KeyboardArrowUp className={styles.arrowUpDown} />
          </IconButton>

          <div className={styles.pageNumberContainer}>
            <TextField
              size="small"
              value={transientPage}
              error={!isValid}
              onChange={handleChange}
              className={styles.pageInput}
              sx={{
                width: 50,
                "& .MuiInputBase-root": {
                  height: 28,
                  fontFamily: "Roboto",
                  fontSize: "15px",
                  backgroundColor: "rgba(255, 255, 255, 0.1)",
                  borderRadius: "6px",
                  padding: "0 8px",
                },
                "& .MuiOutlinedInput-notchedOutline": {
                  borderColor: "rgba(255, 255, 255, 0.2)",
                },
                "& input": {
                  color: "white",
                  textAlign: "center",
                },
              }}
            />
            <span className={styles.pageDivider}>of</span>
            <span className={styles.pageTotal}>{totalPages}</span>
          </div>

          <IconButton onClick={() => onPageChange(currentPage - 1)}>
            <KeyboardArrowDown className={styles.arrowUpDown} />
          </IconButton>
        </div>

        {/* Zoom Control Section */}
        <div className={styles.zoomControl}>
          <IconButton onClick={() => onZoomChange(zoomLevel - 10)}>
            <ZoomOut />
          </IconButton>
          <span>{zoomLevel}%</span>
          <IconButton onClick={() => onZoomChange(zoomLevel + 10)}>
            <ZoomIn />
          </IconButton>
        </div>
      </Box>
    </div>
  );
}


```
File: /Users/tarioyou/ListenInk/frontend/src/components/PDFViewer/PdfViewer.module.scss
Content:```
// Your color palette
$dark-blue: #1d3557;
$pale: #f1faee;
$light-blue: #a8dadc;
$medium-blue: #457b9d;

$pdfViewerHeight: calc(100vh - 50px);

.pdfViewer {
  width: 100%;
  height: 100%;
  background-color: $pale;
  display: flex;
  position: relative;
}

.pdfScrollContainer {
  width: 100%;
  height: 100%;
  overflow-y: auto;
  scroll-behavior: smooth;
  scrollbar-width: thin;
  scrollbar-color: $medium-blue $pale;
  
  &::-webkit-scrollbar {
    width: 10px;
  }
  
  &::-webkit-scrollbar-track {
    background: $pale;
  }
  
  &::-webkit-scrollbar-thumb {
    background-color: $medium-blue;
    border-radius: 6px;
    border: 3px solid $pale;
  }
}

.multiPageContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 0; /* Changed from 20px 0 to 0 */
  gap: 30px;
}

.pdfPage {
  background-color: white;
  box-shadow: 0 4px 10px rgba($dark-blue, 0.15);
  width: 100%; /* Changed from 85% to 100% */
  max-width: 100%; /* Changed from 800px to 100% */
  padding: 0; /* Changed from 15px to 0 */
  position: relative;
  border-radius: 0; /* Changed from 4px to 0 */
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.pageNumber {
  position: absolute;
  bottom: 10px;
  right: 10px;
  background-color: rgba($medium-blue, 0.8);
  color: $pale;
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 12px;
  box-shadow: 0 2px 4px rgba($dark-blue, 0.2);
}

// Optional scroll indicator
.scrollIndicator {
  position: absolute;
  right: 15px;
  bottom: 100px;
  background-color: rgba($dark-blue, 0.8);
  color: $pale;
  padding: 10px;
  border-radius: 20px;
  font-size: 14px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
  
  .indicator {
    width: 4px;
    height: 100px;
    background-color: rgba($pale, 0.3);
    border-radius: 2px;
    position: relative;
    
    .progress {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      background-color: $pale;
      border-radius: 2px;
    }
  }
}

```
File: /Users/tarioyou/ListenInk/frontend/src/components/PDFViewer/pdfTopBar.module.scss
Content:```
$arrow-size: 15px;
$overall-height: 40px;
$icon-size: 40px;
$dark-background: rgba(26, 26, 46, 0.85);
$light-text: rgba(255, 255, 255, 0.9);

.pdfTopBar {
  background-color: $dark-background;
  backdrop-filter: blur(15px);
  border-radius: 16px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.35);
  border: 1px solid rgba(255, 255, 255, 0.08);
}


/* styles for the simple search icon */
.searchIcon {
  width: $icon-size;
  height: $icon-size;
  color: $light-text;
  transition: transform 0.2s ease;
  
  &:hover {
    color: white;
    transform: scale(1.1);
  }
}

/* styles for the page number display section */
.pageNumberDisplayBox {
  width: 200px;
  height: $overall-height;
  display: flex;
  align-items: center;
  color: $light-text;

  .arrowUpDown {
    width: $arrow-size;
    height: $arrow-size;
    color: $light-text;
  }
  
  .pageInput {
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    
    input {
      color: white;
    }
  }
  
  .pageDivider, .pageTotal {
    color: $light-text;
  }
}

.zoomControl {
  height: 40px;
  margin-left: 200px;
  color: $light-text;
  
  span {
    margin: 0 8px;
  }
  
  button {
    color: $light-text;
    
    &:hover {
      color: white;
      transform: scale(1.1);
    }
  }
}

.pageNumberContainer {
  display: flex;
  align-items: center;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  padding: 2px 8px;
  margin: 0 5px;
}

.pageDivider {
  margin: 0 5px;
  font-size: 12px;
  color: rgba(255, 255, 255, 0.7);
}

.pageTotal {
  font-size: 14px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.9);
}

```
File: /Users/tarioyou/ListenInk/frontend/src/components/PDFViewer/PdfViewer.tsx
Content:```
// Inside your PdfViewer.tsx file

import { useEffect, useRef, WheelEvent } from "react";
import styles from "./PdfViewer.module.scss";

interface PdfViewerProps {
  scale: number;
  docId: string;
  totalPages: number;
  currentPage: number;
  onPageChange: (page: number) => void;
}

export function PdfViewer({
  scale,
  docId,
  totalPages,
  currentPage,
  onPageChange,
}: PdfViewerProps) {
  const containerRef = useRef<HTMLDivElement>(null);

  // Create array of all pages
  const allPages = Array.from({ length: totalPages }, (_, i) => i);

  return (
    <div className={styles.pdfViewer}>
      <div ref={containerRef} className={styles.pdfScrollContainer}>
        <div className={styles.multiPageContainer}>
          {allPages.map((pageNum) => (
            <div
              key={pageNum}
              className={`${styles.pdfPage} ${
                pageNum === currentPage ? styles.currentPage : ""
              }`}
              id={`page-${pageNum}`}
            >
              <img
                src={`/api/v1/docs/${docId}/pages/${pageNum}/image`}
                style={{
                  transform: `scale(${scale})`,
                  transformOrigin: "center",
                  transition: "transform 0.2s ease",
                  width: "100%",
                }}
                alt={`PDF page ${pageNum + 1}`}
                loading="lazy"
              />
              <div
                className={styles.pageNumber}
                style={{ backgroundColor: "rgba(26, 26, 46, 0.85)" }}
              >
                {pageNum + 1}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}


```
File: /Users/tarioyou/ListenInk/frontend/src/components/PDFViewer/index.module.scss
Content:```
.mainPdf {
  // the style of elements inside
  // line up
  display: flex;
  flex-direction: column;

  // content fill up the entire outer
  // box defined in Root/Content/index.module.scss
  height: 100%;
  width: 100%;
  background-color: white;
  overflow: hidden; /* Added to prevent scrollbars at the edge */
}

```
File: /Users/tarioyou/ListenInk/frontend/src/components/WithDocument/index.tsx
Content:```
import { RootState } from "@/store";
import { Document } from "@/types";
import { ComponentType } from "react";
import { useSelector } from "react-redux";
import { useParams } from "react-router";

/** A hook that provides a `Document` if a valid document id is provided in the url parameters */
export function useDocument(): Document | undefined {
  const { docId } = useParams();
  const doc = useSelector((state: RootState) => {
    if (state.categories.status === "success") {
      if (docId !== undefined) {
	return state.categories.documents[docId];
      }
    } 
    return undefined;
  });
  return doc;
}

export type InjectedProps = {
  docId: string;
  doc: Document;
};

/** An HOC that passes a `Document` and `Document` id to a wrapped component, rendering null if there is no `Document` for the current URL */
export function withDocument<P extends InjectedProps>(
  WrappedComponent: ComponentType<P>
) {
  return (props: Omit<P, keyof InjectedProps>) => {
    const { docId } = useParams();
    const doc = useDocument();
    if (docId === undefined || doc === undefined) {
      return null;
    }

    const injectedProps: P = {
      ...props,
      docId,
      doc
    } as P; // Omit + the omitted props = the original type, but the typechecker can't verify that 
    return <WrappedComponent {...injectedProps} />;
  };
}


```
File: /Users/tarioyou/ListenInk/frontend/src/components/DrawerHeader/index.tsx
Content:```
// src/components/DrawerHeader/index.tsx
import { ReactNode } from "react";
import { Box } from "@mui/material";
import styles from "./index.module.scss";

interface DrawerHeaderProps {
  children?: ReactNode;
}

export function DrawerHeader({ children }: DrawerHeaderProps) {
  return <Box className={styles.drawerHeader}>{children}</Box>;
}


```
File: /Users/tarioyou/ListenInk/frontend/src/components/DrawerHeader/index.module.scss
Content:```
// src/components/DrawerHeader/index.module.scss
@use "src/styles/drawer";

.drawerHeader {
  display: flex;
  align-items: center;
  padding: 0 16px;
  justify-content: flex-end;
  min-height: drawer.$drawer-height;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
  border-bottom: 1px solid #e0e0e0;
}

```
File: /Users/tarioyou/ListenInk/frontend/src/components/Profile/index.tsx
Content:```
import React, { FC, MouseEvent, useState } from "react";
import { IconButton, Menu, MenuItem, Avatar } from "@mui/material";
import styles from "./index.module.scss"; // Import the SCSS module

/**
 * Profile component with a clickable avatar.
 * Clicking opens a dropdown; includes "Log Out".
 */
export const Profile: FC = () => {
  // MUI menu anchor element (null when closed).
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);

  /** Open the menu by setting the anchor */
  const handleMenuClick = (event: MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  /** Close the menu by clearing the anchor */
  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  /** Example logout action */
  const handleLogout = () => {
    alert("Logged out");
    handleMenuClose(); // also close the menu
  };

  // Whether the menu is open depends on anchorEl
  const open = Boolean(anchorEl);

  return (
    <div>
      {/* Avatar Button */}
      <IconButton
        onClick={handleMenuClick}
        sx={{
          padding: 0,
          margin: 0,
          backgroundColor: "rgba(255, 255, 255, 0.1)",
          "&:hover": {
            backgroundColor: "rgba(255, 255, 255, 0.15)",
            transform: "scale(1.05)",
          },
          transition: "all 0.3s ease",
        }}
      >
        <Avatar
          sx={{
            width: 40,
            height: 40,
            backgroundColor: "rgba(30, 30, 45, 0.9)", // Dark background instead of purple
            color: "white",
            fontWeight: "bold",
            fontSize: "18px",
            border: "2px solid rgba(255, 255, 255, 0.2)",
          }}
        >
          {/* Use first initial of the user or a custom icon */}U
        </Avatar>
      </IconButton>

      {/* Dropdown Menu */}
      <Menu
        anchorEl={anchorEl}
        open={open}
        onClose={handleMenuClose}
        // optional: position the menu exactly as you like
        anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
        transformOrigin={{ vertical: "top", horizontal: "right" }}
      >
        <MenuItem onClick={handleLogout}>Log Out</MenuItem>
      </Menu>
    </div>
  );
};

export default Profile;


```
File: /Users/tarioyou/ListenInk/frontend/src/components/Profile/index.module.scss
Content:```
// index.module.scss

.hoverIconButton {
    position: relative;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background-color: transparent;
    transition: all 0.3s ease;
  }
  
  .hoverIconButton::before {
    content: "";
    position: absolute;
    top: -3px;
    left: -3px;
    width: calc(100% + 6px);
    height: calc(100% + 6px);
    background-color: rgba(236, 236, 236, 1);
    border-radius: 50%;
    opacity: 0;
    transition: all 0.3s ease;
    z-index: -1;
  }
  
  .hoverIconButton:hover::before {
    opacity: 1;
  }
  

```
File: /Users/tarioyou/ListenInk/frontend/src/components/AudioControls/index.tsx
Content:```
import { Component, createRef, RefObject, MouseEvent } from "react";
import { connect, ConnectedProps } from "react-redux";
import {
  Box,
  Button,
  FormControl,
  MenuItem,
  Select,
  SelectChangeEvent,
  Typography,
} from "@mui/material";
import { InjectedProps, withDocument } from "@/components/WithDocument";
import {
  AppDispatch,
  RootState,
  setIsPlaying,
  setPlaybackSpeed,
  upsertBookmark,
} from "@/store";
import { PlaybackSpeed } from "@/store/slices/categories";
import styles from "./index.module.scss";

interface AudioControlsState {
  duration?: number;
  volume: number;
}

function mapStateToProps(state: RootState, ownProps: InjectedProps) {
  if (state.categories.status === "success") {
    const doc = state.categories.documents[ownProps.docId];
    return {
      isPlaying: doc?.isPlaying ?? false,
      playbackPos: doc?.bookmarks.at(0)?.audiotime ?? 0,
      playbackSpeed: doc?.playbackSpeed ?? "1",
      currentPage: doc?.bookmarks.at(0)?.page ?? 0,
      docId: doc?.id,
    };
  } else {
    throw new Error(
      "Impossible state reached - withDocuments() asserts that documents are loaded!"
    );
  }
}
function mapDispatchToProps(dispatch: AppDispatch, ownProps: InjectedProps) {
  return {
    setIsPlaying: (isPlaying: boolean) =>
      dispatch(setIsPlaying({ id: ownProps.docId, isPlaying })),
    setPlaybackSpeed: (playbackSpeed: PlaybackSpeed) =>
      dispatch(setPlaybackSpeed({ id: ownProps.docId, playbackSpeed })),
    setPlaybackPos: (pos: number) =>
      dispatch(upsertBookmark({ docId: ownProps.docId, time: pos })),
  };
}
const connector = connect(mapStateToProps, mapDispatchToProps);
type PropsFromRedux = ConnectedProps<typeof connector>;

function isPlaybackSpeed(speed: string): speed is PlaybackSpeed {
  switch (speed) {
    case "0.25":
    case "0.5":
    case "1":
    case "1.25":
    case "1.5":
    case "2":
      return true;
    default:
      return false;
  }
}

function formatTime(seconds?: number) {
  if (seconds !== undefined) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, "0")}`;
  } else {
    return "--:--";
  }
}

class AudioControlsComponent extends Component<
  PropsFromRedux,
  AudioControlsState
> {
  audioRef: RefObject<HTMLAudioElement | null>;

  constructor(props: PropsFromRedux) {
    super(props);
    this.state = { duration: undefined, volume: 0.5 };
    this.audioRef = createRef();
  }

  componentDidMount() {
    const audio = this.audioRef.current;
    if (audio !== null) {
      audio.addEventListener("timeupdate", this.handleTimeUpdate);
      audio.addEventListener("ended", this.handleEnded);
      audio.addEventListener("loadedmetadata", this.handleLoadedMetadata);
      audio.currentTime = this.props.playbackPos;
      audio.volume = this.state.volume;
    }

    this.checkBackgroundColor();
  }

  checkBackgroundColor = () => {
    // This is a simplified approach - for a full implementation you would need to analyze
    // the actual pixels of the PDF under the controls
    const controls = document.querySelector(
      `.${styles.audioControls}`
    ) as HTMLElement;

    if (controls) {
      // For now we'll just set a darker theme by default
      controls.style.backgroundColor = "rgba(60, 60, 70, 0.85)";

      // A more advanced implementation would use a library like color-thief
      // to analyze the PDF content beneath the controls and adapt accordingly
    }
  };

  componentDidUpdate(prevProps: PropsFromRedux) {
    const audio = this.audioRef.current;
    if (audio !== null) {
      if (prevProps.isPlaying !== this.props.isPlaying) {
        this.props.isPlaying ? audio.play() : audio.pause();
      }
      if (prevProps.playbackSpeed !== this.props.playbackSpeed) {
        audio.playbackRate = parseFloat(this.props.playbackSpeed);
      }
      if (Math.abs(audio.currentTime - this.props.playbackPos) > 1) {
        audio.currentTime = this.props.playbackPos;
      }
      audio.volume = this.state.volume;
    }
  }

  componentWillUnmount() {
    const audio = this.audioRef.current;
    if (audio !== null) {
      audio.removeEventListener("timeupdate", this.handleTimeUpdate);
      audio.removeEventListener("ended", this.handleEnded);
      audio.removeEventListener("loadedmetadata", this.handleLoadedMetadata);
    }
  }

  handleTimeUpdate = () => {
    const audio = this.audioRef.current;
    if (audio !== null) {
      // Debounce a little bit so we don't spam the server
      if (Math.abs(audio.currentTime - this.props.playbackPos) > 1) {
        // audio.currentTime is in seconds
        this.props.setPlaybackPos(audio.currentTime);
      }

      // Sometimes we can get the audio position right out of the gate, but other times we have to wait until we start playing for that data to be available
      this.handleLoadedMetadata();
    }
  };

  handleEnded = () => {
    this.props.setIsPlaying(false);
  };

  handleLoadedMetadata = () => {
    const audio = this.audioRef.current;
    if (
      audio !== null &&
      isFinite(audio.duration) &&
      this.state.duration === undefined
    ) {
      this.setState({ duration: audio.duration });
    }
  };

  handleRewind = () => {
    this.props.setPlaybackPos(Math.max(0, this.props.playbackPos - 10));
  };

  handleSkip = () => {
    if (this.state.duration !== undefined) {
      this.props.setPlaybackPos(
        Math.min(this.state.duration, this.props.playbackPos + 10)
      );
    }
  };

  handlePlayPause = () => {
    this.props.setIsPlaying(!this.props.isPlaying);
  };

  handlePlaybackSpeedChange = (e: SelectChangeEvent) => {
    const speed = e.target.value;
    if (isPlaybackSpeed(speed)) {
      this.props.setPlaybackSpeed(speed);
    } else {
      console.error(
        "Error! Received impossible input from select element: ",
        speed
      );
    }
  };

  handlePlaybarClick = (e: MouseEvent<HTMLSpanElement>) => {
    if (this.state.duration !== undefined) {
      // Get the bounding box of the span
      const rect = e.currentTarget.getBoundingClientRect();
      // Calculate the x-coordinate of the click relative to the span
      const clickX = e.clientX - rect.left;
      // Calculate the width of the span
      const spanWidth = rect.width;

      // Use that to calculate the new time to jump to
      this.props.setPlaybackPos(this.state.duration * (clickX / spanWidth));
    }
  };

  handleVolumeChange = (_: Event, newValue: number | number[]) => {
    // I'm not sure what a `number[]` means in terms of the slider, so I'm going to ignore it
    if (!Array.isArray(newValue)) {
      this.setState({ volume: newValue / 100 });
    }
  };

  render() {
    const { playbackPos, playbackSpeed, isPlaying, currentPage, docId } =
      this.props;
    const fractionComplete =
      this.state.duration === undefined ? 0 : playbackPos / this.state.duration;
    const timePlayed = Math.floor(playbackPos);
    const timeRemaining =
      this.state.duration === undefined ? 0 : this.state.duration - timePlayed;

    return (
      <Box className={styles.audioControls}>
        {/* Hidden audio element */}
        <audio
          ref={this.audioRef}
          src={`/api/v1/docs/${docId}/pages/${currentPage}/audio`}
        />

        <div className={styles.progressContainer}>
          <Typography className={styles.timePlayed}>
            {formatTime(timePlayed)}
          </Typography>

          {/* Rewind button */}
          <Button onClick={this.handleRewind} className={styles.controlButton}>
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="27"
              viewBox="0 0 24 27"
              fill="currentColor"
            >
              <path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z" />
              <text
                x="12"
                y="25"
                fontSize="6"
                fill="white"
                textAnchor="middle"
                style={{ fontWeight: "bold" }}
              >
                -10
              </text>
            </svg>
          </Button>

          {/* Play/Pause Button */}
          <Button
            variant="contained"
            onClick={this.handlePlayPause}
            className={styles.playPauseButton}
          >
            {isPlaying ? (
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="currentColor"
              >
                <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
              </svg>
            ) : (
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="currentColor"
              >
                <path d="M8 5v14l11-7z" />
              </svg>
            )}
          </Button>

          {/* Forward button */}
          <Button onClick={this.handleSkip} className={styles.controlButton}>
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="27"
              viewBox="0 0 24 27"
              fill="currentColor"
            >
              <path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z" />
              <text
                x="12"
                y="25"
                fontSize="6"
                fill="white"
                textAnchor="middle"
                style={{ fontWeight: "bold" }}
              >
                +10
              </text>
            </svg>
          </Button>

          {/* Progress bar */}
          <Box className={styles.progressBar} onClick={this.handlePlaybarClick}>
            <Box
              className={styles.progress}
              style={{
                width: `${fractionComplete * 100}%`,
              }}
            />
          </Box>

          <Typography className={styles.timeRemaining}>
            -{formatTime(timeRemaining)}
          </Typography>

          {/* Speed control */}
          <FormControl size="small">
            <Select
              value={playbackSpeed}
              onChange={this.handlePlaybackSpeedChange}
              sx={{
                fontSize: "12px",
                height: "30px",
                minWidth: "60px",
                color: "#1d3557",
                ".MuiOutlinedInput-notchedOutline": {
                  borderColor: "rgba(29, 53, 87, 0.3)",
                },
                "&:hover .MuiOutlinedInput-notchedOutline": {
                  borderColor: "rgba(29, 53, 87, 0.5)",
                },
              }}
            >
              <MenuItem value={"0.5"}>0.5x</MenuItem>
              <MenuItem value={"1"}>1x</MenuItem>
              <MenuItem value={"1.25"}>1.25x</MenuItem>
              <MenuItem value={"1.5"}>1.5x</MenuItem>
              <MenuItem value={"2"}>2x</MenuItem>
            </Select>
          </FormControl>
        </div>
      </Box>
    );
  }
}

export const AudioControls = withDocument(connector(AudioControlsComponent));


```
File: /Users/tarioyou/ListenInk/frontend/src/components/AudioControls/index.module.scss
Content:```
// Your color palette
$dark-blue: #1d3557;
$pale: #ffffff;
$light-blue: #a8dadc;
$medium-blue: #457b9d;

.audioControls {
  position: absolute;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  width: 80%;
  max-width: 800px;
  padding: 8px 18px;
  background-color: rgba(60, 60, 70, 0.85); // Darker, more opaque background
  backdrop-filter: blur(15px);
  border-radius: 30px;
  z-index: 20;
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
  border: 1px solid rgba(255, 255, 255, 0.18); // Subtle border
}

.controlPanel {
  display: flex;
  align-items: center;
  gap: 15px;
  justify-content: center;
  padding: 0 10px;
}

.timeDisplay {
  display: flex;
  align-items: center;
}

// New layout with progress bar inline with controls
.progressContainer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
}

.progressBar {
  flex-grow: 1;
  height: 6px; // Slightly taller
  background: rgba(255, 255, 255, 0.25); // Lighter background for contrast
  margin: 0 15px;
  position: relative;
  border-radius: 3px;
  cursor: pointer;
  overflow: hidden;
}

.progress {
  height: 100%;
  background: rgba(255, 255, 255, 0.9); // Bright white progress
  border-radius: 3px;
  
  &::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 12px;
    height: 12px;
    background-color: white;
    border-radius: 50%;
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.5); // Glow effect
  }
}

.timePlayed, .timeRemaining {
  font-family: 'Roboto', sans-serif;
  font-size: 12px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.9); // Bright white text
  min-width: 40px;
}

.playPauseButton {
  background-color: transparent !important;
  color: rgba(255, 255, 255, 0.9) !important;
  width: auto !important;
  height: auto !important;
  min-width: auto !important;
  padding: 6px 12px !important;
  border-radius: 8px !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  box-shadow: none !important;
  
  &:hover {
    background-color: rgba(255, 255, 255, 0.1) !important;
    transform: scale(1.05) !important;
  }
}

.controlButton {
  color: rgba(255, 255, 255, 0.8); // Light colored controls
  transition: all 0.2s ease;
  
  &:hover {
    color: white;
    transform: scale(1.1);
  }
}

:global(.MuiSelect-select), :global(.MuiInputBase-root) {
  color: rgba(255, 255, 255, 0.9) !important;
}

:global(.MuiOutlinedInput-notchedOutline) {
  border-color: rgba(255, 255, 255, 0.3) !important;
}

:global(.MuiSelect-icon) {
  color: rgba(255, 255, 255, 0.7) !important;
}

```
File: /Users/tarioyou/ListenInk/frontend/src/pages/urlfor.tsx
Content:```
export function urlFor(page: "docs", context: string): string {
  if (page === "docs") {
    return `/docs/${context}`;
  }

  // Impossible, return home
  return "";
}


```
File: /Users/tarioyou/ListenInk/frontend/src/pages/Auth/index.tsx
Content:```
export function Auth() {
  return <h1>It also works!</h1>
}


```
File: /Users/tarioyou/ListenInk/frontend/src/pages/Root/index.tsx
Content:```
// src/pages/Root/index.tsx
import { connect, ConnectedProps } from "react-redux";
import Box from "@mui/material/Box";
import { AppDispatch, RootState, setSidebar } from "@/store";
import { Profile } from "@/components/Profile";
import { Menu as ChevronRight } from "@mui/icons-material";
import { IconButton, Tooltip } from "@mui/material";

import styles from "./index.module.scss";

// I made a very arbitrary choice here that I don't love
// All these components really only make sense in the context of the <Root /> page
// This component kind of does its own thing (but is still very context dependent on <Root />
import { SearchDialog } from "@/components/SearchDialog";
// ... but these components are just layout abstractions for how stuff is laid out
// import { MenuBar } from "./MenuBar";
import { Sidebar } from "./Sidebar";
import { Content } from "./Content";
// Should these all be grouped together? Probably!

// Unfortunately, TypeScript kinda freaks out if you let infer too much stuff at once
// By pulling these props out, we can handhold the typechecker so it doesn't think that
// these Redux-provided props are something other components need to worry about
const mapStateToProps = (state: RootState) => ({
  sidebarOpen: state.ui.sidebarOpen,
});

const mapDispatchToProps = (dispatch: AppDispatch) => ({
  openSidebar: () => dispatch(setSidebar(true)),
});

const connector = connect(mapStateToProps, mapDispatchToProps);
type PropsFromRedux = ConnectedProps<typeof connector>;

function RootComponent({ sidebarOpen, openSidebar }: PropsFromRedux) {
  return (
    <Box className={styles.root}>
      {/* Add menu button that only appears when sidebar is closed */}
      {!sidebarOpen && (
        <div className={styles.floatingMenu}>
          <Tooltip title="Open Sidebar">
            <IconButton
              onClick={openSidebar}
              className={styles.menuButton}
              size="medium"
              color="primary"
            >
              <ChevronRight />
            </IconButton>
          </Tooltip>
        </div>
      )}

      <Sidebar />
      <Content />
      <SearchDialog />

      {/* Floating Profile in top right */}
      <div className={styles.floatingProfile}>
        <Profile />
      </div>
    </Box>
  );
}

export const Root = connector(RootComponent);


```
File: /Users/tarioyou/ListenInk/frontend/src/pages/Root/index.module.scss
Content:```
.root {
  display: flex;
  position: relative;
  background: linear-gradient(180deg, #121212, #1a1a2e);
  min-height: 100vh;
}

.floatingProfile {
  position: absolute;
  top: 15px;
  right: 15px;
  z-index: 100;
  background-color: transparent; // Remove white backing
  border-radius: 50%;
  padding: 5px;
  transition: all 0.3s ease;
  
  &:hover {
    background-color: rgba(255, 255, 255, 0.15);
    transform: scale(1.05);
  }
}


.floatingMenu {
  position: absolute;
  top: 15px;
  left: 15px;
  z-index: 100;
  border-radius: 50%;
  padding: 5px;
  background-color: transparent; // Remove white backing
  transition: opacity 0.3s ease, transform 0.3s ease;
  animation: fadeIn 0.3s ease;
}

.menuButton {
  background-color: rgba(26, 26, 46, 0.8) !important; // Add dark background
  color: rgba(255, 255, 255, 0.9) !important; // Make icon white
  border: 1px solid rgba(255, 255, 255, 0.1) !important; // Add subtle border
  
  &:hover {
    // background-color: rgba(255, 255, 255, 0.1) !important;
    transform: scale(1.05);
  }
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateX(-10px); }
  to { opacity: 1; transform: translateX(0); }
}

```
File: /Users/tarioyou/ListenInk/frontend/src/pages/Root/Sidebar/index.tsx
Content:```
// src/pages/Root/Sidebar/index.tsx
import { useRef, useState, MouseEvent, ChangeEvent } from "react";
import {
  Drawer,
  IconButton,
  Divider,
  Box,
  Menu,
  MenuItem,
  Typography,
  Tooltip,
} from "@mui/material";
import {
  ChevronLeft,
  Search,
  Upload,
  Add,
  Book,
  AutoStories,
  FolderSpecial,
  Description,
} from "@mui/icons-material";
import { DrawerHeader } from "@/components/DrawerHeader";
import { Categories } from "../Categories";
import styles from "./index.module.scss";
import { connect, ConnectedProps } from "react-redux";
import {
  AppDispatch,
  createDocument,
  RootState,
  setSearchDialog,
  setSidebar,
  upsertCategory,
} from "@/store";
import { useNavigate } from "react-router";
import { urlFor } from "@/pages/urlfor";
import { useDocument } from "@/components/WithDocument";

// Redux connection
const mapStateToProps = (state: RootState) => ({
  sidebarOpen: state.ui.sidebarOpen,
});

const mapDispatchToProps = (dispatch: AppDispatch) => ({
  createNewCategory: () =>
    dispatch(upsertCategory({ name: "New Category", color: "#457b9d" })),
  closeSidebar: () => dispatch(setSidebar(false)),
  openDialog: () => dispatch(setSearchDialog(true)),
  createDoc: (file: File, categoryId?: string) =>
    dispatch(createDocument({ file, categoryId })),
});

const connector = connect(mapStateToProps, mapDispatchToProps);
type PropsFromRedux = ConnectedProps<typeof connector>;

function SidebarComponent({
  sidebarOpen,
  closeSidebar,
  openDialog,
  createNewCategory,
  createDoc,
}: PropsFromRedux) {
  const navigate = useNavigate();
  const activeDocument = useDocument();

  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);

  // For the "Upload" button
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  const handleAddClick = (e: MouseEvent<HTMLElement>) => {
    setAnchorEl(e.currentTarget);
  };

  const handleCloseMenu = () => setAnchorEl(null);

  // When user clicks the Upload icon
  const handleUploadClick = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
      handleCloseMenu();
    }
  };

  // Handle file input
  const handleFileChange = async (e: ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    e.target.value = ""; // reset so we can re-upload same file if needed
    if (!file) return;
    const doc = await createDoc(file, activeDocument?.id);
    if (typeof doc.payload !== "string" && doc.payload !== undefined) {
      navigate(urlFor("docs", doc.payload.id));
    }
  };

  const handleCategoryClick = () => {
    createNewCategory();
    handleCloseMenu();
  };

  return (
    <Drawer
      className={styles.drawer}
      variant="persistent"
      anchor="left"
      open={sidebarOpen}
      classes={{ paper: styles.drawerPaper }}
    >
      {/* Custom Header */}
      <Box className={styles.headerContainer}>
        {/* App Title/Logo */}
        <Box className={styles.titleArea}>
          <AutoStories className={styles.logoIcon} />
          <Typography className={styles.appTitle}>ListenInk</Typography>
        </Box>

        {/* Action Buttons */}
        <Box className={styles.actionButtons}>
          <IconButton
            onClick={openDialog}
            className={styles.iconButton}
            size="small"
          >
            <Search />
          </IconButton>

          {/* <IconButton
            onClick={handleUploadClick}
            className={styles.iconButton}
            size="small"
          >
            <Upload />
          </IconButton> */}

          <IconButton
            onClick={handleAddClick}
            className={styles.iconButton}
            size="small"
          >
            <Add />
          </IconButton>

          <IconButton
            onClick={closeSidebar}
            className={styles.iconButton}
            size="small"
          >
            <ChevronLeft />
          </IconButton>
        </Box>

        {/* Hidden file input */}
        <input
          type="file"
          accept="application/pdf"
          ref={fileInputRef}
          style={{ display: "none" }}
          onChange={handleFileChange}
        />

        {/* Add Menu */}
        <Menu
          anchorEl={anchorEl}
          open={Boolean(anchorEl)}
          onClose={handleCloseMenu}
          PaperProps={{
            elevation: 3,
            sx: {
              borderRadius: "8px",
              mt: 1,
              "& .MuiMenuItem-root": {
                px: 2,
                py: 1,
                borderRadius: "4px",
                mx: 1,
                my: 0.5,
                fontSize: "14px",
              },
            },
          }}
        >
          <MenuItem onClick={handleUploadClick}>
            <Description fontSize="small" sx={{ mr: 1 }} />
            Create New Document
          </MenuItem>
          <MenuItem onClick={handleCategoryClick}>
            <FolderSpecial fontSize="small" sx={{ mr: 1 }} />
            Create New Category
          </MenuItem>
        </Menu>
      </Box>

      <Divider />

      {/* Categories with enhanced styling will be handled in the Categories component */}
      <Box className={styles.categoriesContainer}>
        <Categories />
      </Box>
    </Drawer>
  );
}

export const Sidebar = connector(SidebarComponent);


```
File: /Users/tarioyou/ListenInk/frontend/src/pages/Root/Sidebar/index.module.scss
Content:```
// src/pages/Root/Sidebar/index.module.scss
@use "src/styles/drawer";

// Color variables
$sidebar-bg: #1a1a2e; // Darker background
$sidebar-text: #e6e6e6; // Lighter text
$sidebar-hover: #252542; // Darker hover
$sidebar-active: #303056; // Darker active
$sidebar-border: #2a2a46; // Darker border
$primary-accent: #6c63ff; // More vibrant accent
$secondary-accent: #a8dadc; // Keep this accent

.drawer {
  width: drawer.$drawer-width;
  flex-shrink: 0;
  position: relative;
  overflow: hidden;
}

.drawerPaper {
  width: drawer.$drawer-width;
  box-sizing: border-box;
  background-color: $sidebar-bg;
  border-right: 1px solid $sidebar-border;
  box-shadow: 0 2px 15px rgba(0, 0, 0, 0.2);
  transition: all 0.3s ease;

  // Change the subtle pattern background
  // background-image: linear-gradient(
  //   rgba(255, 255, 255, 0.03) 1px,
  //   transparent 1px
  // );
  // background-size: 100% 30px;
}


// Enhanced header styles
.headerContainer {
  padding: 18px 12px;
  background-color: rgba(0, 0, 0, 0.15);
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.08);
  border-bottom: 1px solid $sidebar-border;
}

// App title/logo area
.titleArea {
  display: flex;
  align-items: center;
  margin-bottom: 16px;
  padding: 0 8px;
  
  .appTitle {
    font-weight: 600;
    font-size: 18px;
    color: white;
    margin-left: 10px;
    letter-spacing: 0.5px;
  }
  
  .logoIcon {
    color: $primary-accent;
    font-size: 24px;
  }
}


// Button group styles
.actionButtons {
  .iconButton {
    color: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 8px;
    transition: all 0.2s ease;
    
    &:hover {
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
      transform: translateY(-1px);
    }
  }
}

// Category section styles
.categoriesContainer {
  &::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.15);
    border-radius: 10px;
    
    &:hover {
      background-color: rgba(255, 255, 255, 0.25);
    }
  }
}

// Category item styles
.categoryItem {
  border-radius: 8px;
  margin: 0 8px 6px;
  transition: all 0.2s ease;
  
  &:hover:not(.active) {
    background-color: rgba(255, 255, 255, 0.09); // Toned down by 50%
    transform: translateX(2px); // Subtle movement on hover
  }
  
  &.active {
    background-color: rgba(108, 99, 255, 0.125); // Toned down by 50%
    
    &:hover {
      background-color: rgba(108, 99, 255, 0.175); // Toned down by 50%
    }
  }
}

// Document item styles
.documentItem {
  padding: 0; // Remove padding from container
  margin: 2px 8px 2px 24px;
  border-radius: 4px;
  position: relative;
  font-size: 14px;
  transition: all 0.2s ease;
  color: rgba(255, 255, 255, 0.6);
  
  // Remove any existing styling that might be causing double highlights
  border: none;
  outline: none;
  
  :global(.MuiListItemButton-root) {
    &.active {
      background-color: rgba(108, 99, 255, 0.125); // Toned down by 50%
      color: white;
      font-weight: 500;
      
      &:hover {
        background-color: rgba(108, 99, 255, 0.175); // Toned down by 50%
      }
    }
    
    &:hover:not(.active) {
      background-color: rgba(255, 255, 255, 0.09); // Toned down by 50%
      transform: translateX(2px); // Subtle movement on hover
    }
  }
}

.docIcon {
  margin-right: 10px;
  color: rgba(255, 255, 255, 0.6); // Dimmer icon color
}

// Fade-in animation for items
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.animated {
  animation: fadeIn 0.3s ease forwards;
}

.documentName {
  color: rgba(255, 255, 255, 0.7); // Ensuring the text color is dimmer
  font-size: 14px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
}

```
File: /Users/tarioyou/ListenInk/frontend/src/pages/Root/MenuBar/index.tsx
Content:```
import { AppBar, Toolbar, IconButton, Typography, Box } from "@mui/material";
import { Menu as MenuIcon } from "@mui/icons-material";
import { useDocument } from "@/components/WithDocument";
import styles from "./index.module.scss";
import { Profile } from "@/components/Profile";

interface MenuProps {
  sidebarOpen: boolean;
  setOpen: () => void;
}

export function MenuBar({ sidebarOpen, setOpen }: MenuProps) {
  const doc = useDocument();

  return (
    <AppBar
      position="fixed"
      className={`${styles.appBar} ${sidebarOpen ? styles.appBarOpen : ""}`}
    >
      <Toolbar>
        {/* Left button to toggle sidebar */}
        <IconButton
          color="inherit"
          aria-label="open drawer"
          onClick={setOpen}
          edge="start"
          className={`${styles.menuButton} ${sidebarOpen ? styles.hidden : ""}`}
        >
          <MenuIcon />
        </IconButton>

        {/* Document name */}
        <Typography variant="h6" noWrap>
          {doc?.name}
        </Typography>

        {/* Spacer to push Profile to the right */}
        <Box sx={{ flexGrow: 1 }} />

        {/* Profile avatar/dropdown */}
        <Profile />
      </Toolbar>
    </AppBar>
  );
}


```
File: /Users/tarioyou/ListenInk/frontend/src/pages/Root/MenuBar/index.module.scss
Content:```
@use "src/styles/drawer";

.appBar {
  transition: margin 0.3s ease-out, width 0.3s ease-out;
  background-color: white;
}

.appBarOpen {
  width: calc(100% - #{drawer.$drawer-width});
  margin-left: drawer.$drawer-width;
}

.menuButton {
  margin-right: 16px;
}

.hidden {
  display: none;
}


```
File: /Users/tarioyou/ListenInk/frontend/src/pages/Root/Content/index.tsx
Content:```
// --- frontend/src/pages/Root/Content/index.tsx ---
import { useEffect } from "react";
import { DrawerHeader } from "@/components/DrawerHeader";
import { PDFViewer } from "@/components/PDFViewer";
import { AudioControls } from "@/components/AudioControls";
import { useDocument } from "@/components/WithDocument";
import styles from "./index.module.scss";
import PDFDropModal from "@/components/PDFDropModal";
import { AppDispatch, RootState, setPdfDropModal } from "@/store";
import { connect, ConnectedProps } from "react-redux";
import { CloudUpload } from "@mui/icons-material";

const mapState = (state: RootState) => ({
  sidebarOpen: state.ui.sidebarOpen,
});

const mapDispatch = (dispatch: AppDispatch) => ({
  setPdfModalOpen: (open: boolean) => dispatch(setPdfDropModal(open)),
});
const connector = connect(mapState, mapDispatch);
type PropsFromRedux = ConnectedProps<typeof connector>;

function ContentComponent({ sidebarOpen, setPdfModalOpen }: PropsFromRedux) {
  const doc = useDocument();

  useEffect(() => {
    let dragCounter = 0;
    const handleDragEnter = (e: DragEvent) => {
      // Only if user is dragging "Files"
      if (
        e.dataTransfer &&
        Array.from(e.dataTransfer.types).includes("Files")
      ) {
        dragCounter++;
        setPdfModalOpen(true);
      }
    };
    const handleDragLeave = () => {
      dragCounter--;
      if (dragCounter <= 0) {
        dragCounter = 0;
        setPdfModalOpen(false);
      }
    };
    const handleDragOver = (e: DragEvent) => {
      e.preventDefault();
    };
    const handleDrop = () => {
      dragCounter = 0;
      setPdfModalOpen(false);
    };

    window.addEventListener("dragenter", handleDragEnter);
    window.addEventListener("dragleave", handleDragLeave);
    window.addEventListener("dragover", handleDragOver);
    window.addEventListener("drop", handleDrop);

    return () => {
      window.removeEventListener("dragenter", handleDragEnter);
      window.removeEventListener("dragleave", handleDragLeave);
      window.removeEventListener("dragover", handleDragOver);
      window.removeEventListener("drop", handleDrop);
    };
  }, [setPdfModalOpen]);

  return (
    <main className={`${styles.main} ${sidebarOpen ? styles.mainOpen : ""}`}>
      {/* <DrawerHeader /> */}

      {/* If doc is selected, show PDF + Audio. Else show empty. */}
      {/* makes sure that the pdfViewer is centered */}
      {doc ? (
        <div className={styles.pdfViewerContainer}>
          <PDFViewer />
          <AudioControls /> {/* This will now float over the PDF */}
        </div>
      ) : (
        <div className={styles.emptyStateMessage}>
          <CloudUpload fontSize="large" />
          <p>
            No Document Selected. Drag & drop a PDF to create one, or pick from
            the Sidebar.
          </p>
        </div>
      )}

      <PDFDropModal />
    </main>
  );
}

export const Content = connector(ContentComponent);


```
File: /Users/tarioyou/ListenInk/frontend/src/pages/Root/Content/index.module.scss
Content:```
@use "src/styles/drawer";

.main {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  flex-grow: 1;
  padding: 0;
  transition: margin 0.3s ease-out;
  margin-left: -(#{drawer.$drawer-width});
  position: relative;
  background: linear-gradient(135deg, #151515, #1f1f35);
  color: white;
}

.mainOpen {
  margin-left: 0;
}
// pdfViewerPosition style
// is used to center the pdf
// viewer.
// New container for both PDF and Audio controls
.pdfViewerContainer {
  position: relative;
  width: 100%;
  height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background-color: rgba(20, 20, 30, 0.7);
}

// We can remove or simplify these since AudioControls is now positioned absolutely
.pdfViewerPosition {
  width: 100%;
  height: 100%;
}

// AudioControls has its own positioning now
.audioControlPosition {
  position: relative; // This is fine since AudioControls now has absolute positioning
}

.emptyStateMessage {
  text-align: center;
  margin-top: 2rem;
  color: rgba(255, 255, 255, 0.85);
  font-size: 1.1rem;
  line-height: 1.6;
  max-width: 500px;
  padding: 20px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.08);
  
  svg {
    font-size: 3rem;
    margin-bottom: 15px;
    opacity: 0.8;
  }
}

```
File: /Users/tarioyou/ListenInk/frontend/src/pages/Root/Categories/index.tsx
Content:```
// --------------------------------------------------
// File: src/pages/Root/Categories/index.tsx
// Updated so RIGHT-CLICK rename mirrors double-click logic
// --------------------------------------------------

// src/pages/Root/Categories/index.tsx
import {
  List,
  ListItemButton,
  ListItemText,
  Collapse,
  TextField,
  Menu,
  MenuItem,
  Box,
  Tooltip,
  Typography,
} from "@mui/material";
import {
  KeyboardArrowRight,
  KeyboardArrowDown,
  Edit,
  Delete,
  Palette,
  Description,
  Folder,
  FolderOpen,
  DragIndicator,
} from "@mui/icons-material";
import { connect, ConnectedProps, useDispatch } from "react-redux";
import { useNavigate, useParams } from "react-router";
import { Conditional } from "@/components/Conditional";
import {
  AppDispatch,
  RootState,
  deleteCategory,
  deleteDocument,
} from "@/store";
import { urlFor } from "@/pages/urlfor";
import {
  useState,
  useEffect,
  MouseEvent as ReactMouseEvent,
  DragEvent,
} from "react";
import { Category } from "@/types";
import {
  EnhancedDocument,
  selectCategories,
  updateDocument,
  upsertCategory,
} from "@/store/slices/categories";
import styles from "../Sidebar/index.module.scss";

/** The palette for changing category colors. */
const categoryColors = [
  "#001219",
  "#005f73",
  "#0a9396",
  "#94d2bd",
  "#e9d8a6",
  "#ee9b00",
  "#ca6702",
  "#bb3e03",
  "#ae2012",
  "#9b2226",
];

/** Maps global Redux state into props. */
const mapStateToProps = (state: RootState) => {
  return {
    categories: selectCategories(state),
    status: state.categories.status,
    reason:
      state.categories.status === "failure"
        ? state.categories.message
        : undefined,
  };
};
const connector = connect(mapStateToProps);
type PropsFromRedux = ConnectedProps<typeof connector>;

function CategoriesComponent({ reason, status, categories }: PropsFromRedux) {
  const cats = Object.values(categories).filter(
    (c?: Category): c is Category => c !== undefined
  );
  return (
    <Conditional status={status} reason={reason}>
      <List sx={{ padding: 0 }}>
        {cats.map((cat, index) => (
          <CategoryRow
            key={cat.id}
            category={cat}
            total={cats.length}
            index={index}
          />
        ))}
      </List>
    </Conditional>
  );
}
export const Categories = connector(CategoriesComponent);

/** Represents a single Category row + nested documents. */
interface CategoryRowProps {
  category: Category & { documents: EnhancedDocument[] };
  total: number;
  index: number;
}

function CategoryRow({ category, total, index }: CategoryRowProps) {
  const { docId } = useParams();
  const navigate = useNavigate();
  const dispatch = useDispatch<AppDispatch>();

  // Whether category is "open."
  const [open, setOpen] = useState(false);
  // If user selected a doc here, forcibly open
  const hasSelectedDoc = category.documents.some((d) => d.id === docId);
  const isOpen = open || hasSelectedDoc;

  // For inline rename of category
  const [editingCat, setEditingCat] = useState(false);
  // We keep local catName in sync with Redux changes *when not editing*
  const [catName, setCatName] = useState(category.name);
  useEffect(() => {
    if (!editingCat) setCatName(category.name);
  }, [category.name, editingCat]);

  // For inline rename of docs
  const [editingDocId, setEditingDocId] = useState<string | null>(null);
  const [docName, setDocName] = useState("");
  // Each time we switch which doc is editing, or doc changes in Redux, re-sync
  useEffect(() => {
    if (!editingDocId) return;
    const d = category.documents.find((doc) => doc.id === editingDocId);
    if (d) setDocName(d.name);
  }, [category.documents, editingDocId]);

  // Right-click context menu
  const [ctxMenu, setCtxMenu] = useState<{
    mouseX: number;
    mouseY: number;
    itemType: "category" | "document";
    itemId: string;
  } | null>(null);

  // For color picker anchored at a custom position
  const [colorMenuCoords, setColorMenuCoords] = useState<{
    x: number;
    y: number;
  } | null>(null);

  // Close context on any left-click
  useEffect(() => {
    const close = () => setCtxMenu(null);
    window.addEventListener("click", close);
    return () => window.removeEventListener("click", close);
  }, []);

  // DRAG & DROP with a custom drag preview
  const handleDragStart = (
    e: DragEvent<HTMLButtonElement>,
    doc: EnhancedDocument
  ) => {
    e.dataTransfer.setData("docId", doc.id);
    e.dataTransfer.setData("sourceCatId", category.id);

    // Create a hidden DOM element so setDragImage can show it
    const dragIcon = document.createElement("div");
    dragIcon.style.fontSize = "13px";
    dragIcon.style.padding = "6px 8px";
    dragIcon.style.backgroundColor = "#457b9d";
    dragIcon.style.color = "#fff";
    dragIcon.style.borderRadius = "4px";
    dragIcon.innerText = `Dragging: ${doc.name}`;
    dragIcon.style.position = "absolute";
    dragIcon.style.top = "-9999px";
    dragIcon.style.left = "-9999px";
    document.body.appendChild(dragIcon);

    // Use the hidden element as the drag image
    e.dataTransfer.setDragImage(dragIcon, 0, 0);

    // Remove it when drag ends
    e.currentTarget.addEventListener("dragend", () => {
      document.body.removeChild(dragIcon);
    });
  };

  const handleDragOver = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
  };

  const handleDrop = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    const docId2 = e.dataTransfer.getData("docId");
    const sourceCatId = e.dataTransfer.getData("sourceCatId");
    if (!docId2 || !sourceCatId) return;
    if (sourceCatId === category.id) return; // no move if same cat
    dispatch(
      updateDocument({
        docId: docId2,
        categoryId: category.id,
      })
    );
  };

  // Right-click context
  const handleContextMenu = (
    e: ReactMouseEvent,
    itemType: "category" | "document",
    itemId: string
  ) => {
    e.preventDefault();
    setCtxMenu({
      mouseX: e.clientX + 2,
      mouseY: e.clientY - 6,
      itemType,
      itemId,
    });
  };

  // (1) RENAME from context menu
  const handleRename = () => {
    if (!ctxMenu) return;

    if (ctxMenu.itemType === "category") {
      setEditingCat(true);
      setCatName(category.name);
    } else {
      const doc = category.documents.find((d) => d.id === ctxMenu.itemId);
      if (doc) {
        setEditingDocId(ctxMenu.itemId);
        setDocName(doc.name);
      }
    }
    setCtxMenu(null);
  };

  // Actually rename category
  const commitCatRename = () => {
    const trimmed = catName.trim();
    if (trimmed && trimmed !== category.name) {
      dispatch(upsertCategory({ categoryId: category.id, name: trimmed }));
    }
    setEditingCat(false);
  };

  const commitDocRename = (docId: string) => {
    const trimmed = docName.trim();
    if (trimmed) {
      dispatch(updateDocument({ docId, name: trimmed }));
    }
    setEditingDocId(null);
  };

  // (2) DELETE
  const handleDelete = () => {
    if (!ctxMenu) return;
    if (ctxMenu.itemType === "category") {
      dispatch(deleteCategory({ id: ctxMenu.itemId }));
    } else {
      dispatch(deleteDocument({ id: ctxMenu.itemId }));
    }
    setCtxMenu(null);
  };

  // (3) CHANGE COLOR
  const handleChangeColor = (mouseX: number, mouseY: number) => {
    setColorMenuCoords({ x: mouseX, y: mouseY });
    setCtxMenu(null);
  };

  const pickColor = (c: string) => {
    dispatch(upsertCategory({ categoryId: category.id, color: c }));
    setColorMenuCoords(null);
  };

  // Double-click rename logic (same as context-rename):
  const handleCatDoubleClick = () => {
    setEditingCat(true);
    setCatName(category.name);
  };

  const handleDocDoubleClick = (doc: EnhancedDocument) => {
    setEditingDocId(doc.id);
    setDocName(doc.name);
  };

  return (
    <div
      onDragOver={handleDragOver}
      onDrop={handleDrop}
      className={`${styles.animated}`}
      style={{ animationDelay: `${index * 0.05}s` }}
    >
      {/* Category row */}
      <Box
        className={`${styles.categoryItem} ${
          hasSelectedDoc ? styles.active : ""
        }`}
      >
        <ListItemButton
          onClick={() => setOpen(!isOpen)}
          onContextMenu={(e) => handleContextMenu(e, "category", category.id)}
          // onDoubleClick={handleCatDoubleClick}
          className={styles.categoryLabel}
          disableRipple
          sx={{
            color: category.color,
            padding: "8px 12px",
          }}
        >
          {isOpen ? (
            <FolderOpen
              className={styles.categoryIcon}
              style={{ marginRight: "10px" }}
            />
          ) : (
            <Folder
              className={styles.categoryIcon}
              style={{ marginRight: "10px" }}
            />
          )}

          {editingCat ? (
            <TextField
              variant="standard"
              autoFocus
              value={catName}
              onChange={(e) => setCatName(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === "Enter") {
                  commitCatRename();
                }
              }}
              sx={{
                maxWidth: 160,
                "& .MuiInput-root": {
                  fontSize: "15px",
                },
              }}
            />
          ) : (
            <Typography
              sx={{
                overflow: "hidden",
                textOverflow: "ellipsis",
                whiteSpace: "nowrap",
                fontWeight: 500,
                fontSize: "15px",
              }}
            >
              {category.name}
            </Typography>
          )}
        </ListItemButton>
      </Box>

      <Collapse in={isOpen} timeout="auto" unmountOnExit>
        {category.documents.map((doc, docIndex) => (
          <Box
            key={doc.id}
            className={`${styles.documentItem} ${styles.animated}`}
            style={{ animationDelay: `${docIndex * 0.03 + 0.1}s` }}
          >
            <ListItemButton
              onClick={() => navigate(urlFor("docs", doc.id))}
              onContextMenu={(e) => handleContextMenu(e, "document", doc.id)}
              // onDoubleClick={() => handleDocDoubleClick(doc)}
              disableRipple
              className={doc.id === docId ? styles.active : ""}
              sx={{
                padding: "4px 6px",
                borderRadius: "4px",
                color: "rgba(255, 255, 255, 0.7)",
                "& .MuiListItemIcon-root": {
                  minWidth: "30px", // Reduce icon width to remove spacing
                },
                "& .MuiTouchRipple-root": {
                  display: "none", // Remove ripple effect
                },
              }}
            >
              <Description
                className={styles.docIcon}
                fontSize="small"
                sx={{ color: "rgba(255, 255, 255, 0.7)" }}
              />

              {editingDocId === doc.id ? (
                <TextField
                  variant="standard"
                  autoFocus
                  value={docName}
                  onChange={(e) => setDocName(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === "Enter") {
                      commitDocRename(doc.id);
                    }
                  }}
                  sx={{
                    maxWidth: 160,
                    "& .MuiInput-root": {
                      fontSize: "14px",
                    },
                  }}
                />
              ) : (
                <Typography
                  sx={{
                    fontSize: "14px",
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap",
                    flex: 1,
                    color: "rgba(255, 255, 255, 0.7)",
                  }}
                >
                  {doc.name}
                </Typography>
              )}
            </ListItemButton>
          </Box>
        ))}
      </Collapse>

      {/* Right-click context menu */}
      <Menu
        open={Boolean(ctxMenu)}
        onClose={() => setCtxMenu(null)}
        anchorReference="anchorPosition"
        anchorPosition={
          ctxMenu ? { top: ctxMenu.mouseY, left: ctxMenu.mouseX } : undefined
        }
        PaperProps={{
          elevation: 3,
          sx: {
            borderRadius: "8px",
            "& .MuiMenuItem-root": {
              fontSize: "14px",
              padding: "6px 16px",
            },
          },
        }}
      >
        <MenuItem onClick={handleRename}>
          <Edit sx={{ mr: 1, fontSize: "18px" }} fontSize="small" /> Rename
        </MenuItem>
        {ctxMenu?.itemType === "category" && (
          <MenuItem
            onClick={() =>
              handleChangeColor(ctxMenu.mouseX, ctxMenu.mouseY + 8)
            }
          >
            <Palette sx={{ mr: 1, fontSize: "18px" }} fontSize="small" /> Change
            Color
          </MenuItem>
        )}
        <MenuItem onClick={handleDelete}>
          <Delete sx={{ mr: 1, fontSize: "18px" }} fontSize="small" /> Delete
        </MenuItem>
      </Menu>

      {/* Color picker anchored at custom position */}
      <Menu
        open={Boolean(colorMenuCoords)}
        onClose={() => setColorMenuCoords(null)}
        anchorReference="anchorPosition"
        anchorPosition={
          colorMenuCoords
            ? { top: colorMenuCoords.y, left: colorMenuCoords.x }
            : undefined
        }
        PaperProps={{
          elevation: 3,
          sx: { borderRadius: "8px" },
        }}
      >
        <Box
          sx={{
            display: "grid",
            gridTemplateColumns: "repeat(5, 1fr)",
            gap: 1,
            p: 2,
          }}
        >
          {categoryColors.map((c) => (
            <Box
              key={c}
              sx={{
                width: 28,
                height: 28,
                borderRadius: "50%",
                backgroundColor: c,
                cursor: "pointer",
                transition: "all 0.2s ease",
                border:
                  c === category.color
                    ? "2px solid #000"
                    : "2px solid transparent",
                ":hover": {
                  transform: "scale(1.15)",
                  boxShadow: "0 2px 5px rgba(0,0,0,0.2)",
                },
              }}
              onClick={() => pickColor(c)}
            />
          ))}
        </Box>
      </Menu>
    </div>
  );
}


```
File: /Users/tarioyou/ListenInk/frontend/src/store/helper-types.ts
Content:```
export type Success = "success";
export type Pending = "pending";
export type Failure = "failure";
export type LoadingState = Success | Pending | Failure;

export type PromiseState<T> =
  (T & { status: Success })
  | { status: Pending }
  | { status: Failure, message: string };


```
File: /Users/tarioyou/ListenInk/frontend/src/store/index.ts
Content:```
import { configureStore } from '@reduxjs/toolkit'
import categoriesReducer, { fetchDocuments } from "./slices/categories";
import authReducer, { fetchProfile } from "./slices/auth";
import uiReducer from "./slices/ui";

export const store = configureStore({
  reducer: {
    categories: categoriesReducer,
    auth: authReducer,
    ui: uiReducer,
  },
});

// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export {
  setSidebar,
  setCategory,
  setQuery,
  setSearchDialog,
  setPdfDropModal,
  setPdfDropStatus,
} from "./slices/ui";

export type {
  PDFDropStatus
} from "./slices/ui";

export {
  setIsPlaying,
  setPlaybackSpeed,
  upsertBookmark,
  updateDocument,
  upsertCategory,
  createDocument,
  deleteCategory,
  deleteDocument
} from "./slices/categories";

window.addEventListener("load",  async () => {
  try {
    //fetchProfiles populates the auth slice and sets the necessary cookies for fetchDocuments
    await store.dispatch(fetchProfile()).unwrap();
    await store.dispatch(fetchDocuments()).unwrap();
  } catch (err) {
    console.error("Error during page load:", err);
  }
});


```
File: /Users/tarioyou/ListenInk/frontend/src/store/slices/categories.ts
Content:```
import { z } from "zod";
import { createSlice, createAsyncThunk, PayloadAction, createSelector } from '@reduxjs/toolkit';
import { Bookmark, BookmarkSchema, Category, CategorySchema, Document, DocumentSchema, ErrSchema } from '@/types';
import { PromiseState } from '../helper-types';
import { RootState } from "..";

export type PlaybackSpeed = "0.25" | "0.5" | "1" | "1.25" | "1.5" | "2";
export interface AudioPlayback {
  isPlaying: boolean;
  playbackSpeed: PlaybackSpeed;
}

export type EnhancedDocument = Document & AudioPlayback;
interface CategoriesSuccessState {
  categories: Record<string, Category | undefined>,
  documents: Record<string, EnhancedDocument | undefined>
}

export type CategoriesState = PromiseState<CategoriesSuccessState>;

const initialState = { status: "pending" } as CategoriesState;

// TODO: setIsPlaying, setPlaybackPos, setPlaybackSpeed, setPlaybackEnd

// This is me being evil in TypeScript.
// This lets me dynamically create types like: {id: string, open: boolean}
// This is useful for writing single-purpose reducer actions without
// writing a massive amount of similar interfaces.
type StateChange<K extends string, T> = { id: string } & { [P in K]: T };

export const categoriesSlice = createSlice({
  name: 'categories',
  initialState,
  reducers: {
    setIsPlaying: (state, action: PayloadAction<StateChange<"isPlaying", boolean>>) => {
      if (state.status === "success") {
	const doc = state.documents[action.payload.id];
	if (doc !== undefined) {
	  doc.isPlaying = action.payload.isPlaying;
	}
      }
    },
    setPlaybackSpeed: (state, action: PayloadAction<StateChange<"playbackSpeed", PlaybackSpeed>>) => {
      if (state.status === "success") {
	const doc = state.documents[action.payload.id];
	if (doc !== undefined) {
	  doc.playbackSpeed = action.payload.playbackSpeed;
	}
      }
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchDocuments.pending, (state: CategoriesState) => {
        state.status = 'pending';
      })
      .addCase(fetchDocuments.fulfilled, (_, action: PayloadAction<CategoriesSuccessState>) => {
	// Normally, I would use Immer to modify state, but the typechecker has trust issues 
        return {
	  status: "success",
	  ...action.payload
	}
      })
      .addCase(fetchDocuments.rejected, (_, action: PayloadAction<string | undefined>) => {
        return {
	  status: "failure",
	  message: action.payload ?? "An unknown error occured!"
	}
      });

    builder
      .addCase(upsertBookmark.fulfilled, (state, action: PayloadAction<Bookmark>) => {
	if (state.status === "success") {
	  const doc = state.documents[action.payload.documentId];
	  if (doc === undefined) {
	    console.error(`[ERROR] A document with id ${action.payload.documentId} was accepted by the server, but no matching document exists on the client!`);
	    return;
	  }
	  const index = doc.bookmarks.findIndex(bookmark => bookmark.id === action.payload.id);
	  if (index !== -1) {
	    // If found, replace the existing bookmark
	    doc.bookmarks[index] = action.payload;
	  } else {
	    // If not found, append the new bookmark
	    doc.bookmarks.push(action.payload);
	  }
	  
	} else {
	  // Either fetchDocuments() is still processing or an error occured while it was processing
	  console.error("[ERROR] Cannot reconcile client state with server state! Server accepted a bookmark modification, but the client does not have a valid document list!");
	}
      })
      .addCase(upsertBookmark.rejected, (_, action: PayloadAction<string | undefined>) => {
	console.error(`[ERROR] An error occured when modifying a bookmark: ${action.payload}`);
      });

    builder
      .addCase(updateDocument.fulfilled, (state, action: PayloadAction<Document>) => {
	if (state.status === "success") {
	  const doc = state.documents[action.payload.id];
	  if (doc === undefined) {
	    console.error("[ERROR] The server accepted modifications to a Document that does not exist on the client!");
	  } else {
	    state.documents[action.payload.id] = {...doc, ...action.payload};
	  }
	} else {
	  // Either fetchDocuments() is still processing or an error occured while it was processing
	  console.error("[ERROR] Cannot reconcile client state with server state! Server accepted a Document modification, but the client does not have a valid document list!");
	}
      })
      .addCase(updateDocument.rejected, (_, action: PayloadAction<string | undefined>) => {
	console.error(`[ERROR] An error occured when modifying a Document: ${action.payload}`);
      });

    builder
      .addCase(upsertCategory.fulfilled, (state, action: PayloadAction<Category>) => {
	if (state.status === "success") {
	  const cat = state.categories[action.payload.id];
	  state.categories[action.payload.id] = {...cat, ...action.payload};
	} else {
	  // Either fetchDocuments() is still processing or an error occured while it was processing
	  console.error("[ERROR] Cannot reconcile client state with server state! Server accepted a Category modification, but the client does not have a valid document list!");
	}
      })
      .addCase(upsertCategory.rejected, (_, action: PayloadAction<string | undefined>) => {
	console.error(`[ERROR] An error occured when modifying a Category: ${action.payload}`);
      });

    builder
      .addCase(createDocument.fulfilled, (state, action: PayloadAction<EnhancedDocument>) => {
	if (state.status === "success") {
	  state.documents[action.payload.id] = action.payload;
	} else {
	  console.error("[ERROR] Cannot reconcile client state with server state! Server accepted a Document creation, but the client does not have a valid document list!")
	}
      })
      .addCase(createDocument.rejected, (_, action: PayloadAction<string | undefined>) => {
	console.error(`[ERROR] An error occured creating a new document: ${action.payload}`);
      });

    builder
      .addCase(deleteCategory.fulfilled, (state, action: PayloadAction<string>) => {
	if (state.status === "success") {
	  delete state.categories[action.payload];
	  for (const [key, doc] of Object.entries(state.documents)) {
	    if (doc?.categoryId === action.payload) {
	      delete state.documents[key];
	    }
	  }
	} else {
	  console.error("[ERROR] Cannot reconcile client state with server state! Server accepted a Category deletion, but the client does not have a valid document list!")
	}
      })
      .addCase(deleteCategory.rejected, (_, action: PayloadAction<string | undefined>) => {
	console.error(`[ERROR] Error when deleting a category: ${action.payload}`)
      });

    builder
      .addCase(deleteDocument.fulfilled, (state, action: PayloadAction<string>) => {
	if (state.status === "success") {
	  delete state.documents[action.payload];
	} else {
	  console.error("[ERROR] Cannot reconcile client state with server state! Server accepted a Document deletion, but the client does not have a valid document list!")
	}
      })
      .addCase(deleteDocument.rejected, (_, action: PayloadAction<string | undefined>) => {
	console.error(`[ERROR] Error when deleting a Document: ${action.payload}`)
      });
  }
});

const DocumentsOrErrSchema = z.union([z.array(DocumentSchema), ErrSchema]);
const CategoriesOrErrSchema = z.union([z.array(CategorySchema), ErrSchema]);

/** An async thunk that fetches all the documents and category data from the server.
 * Intended to run once on page load, but can be could again to resync with the server in an evil way
 */  
export const fetchDocuments = createAsyncThunk<
  CategoriesSuccessState,
  void,
  { rejectValue: string }
>(
  'data/fetchDocuments',
  async (_, { rejectWithValue }) => {
    try {
      const docsReq = await fetch("/api/v1/docs");
      const docsResp = DocumentsOrErrSchema.safeParse(await docsReq.json());

      const catsReq = await fetch("/api/v1/categories");
      const catsResp = CategoriesOrErrSchema.safeParse(await catsReq.json());

      if (!docsResp.success) {
	console.error(docsResp.error.message);
	return rejectWithValue("Could not parse document info!");
      }
      if ("err" in docsResp.data) {
	return rejectWithValue(docsResp.data.err);
      }

      if (!catsResp.success) {
	return rejectWithValue("Could not parse categories info!");
      }
      if ("err" in catsResp.data) {
	return rejectWithValue(catsResp.data.err);
      }

      return {
	documents: docsResp.data.reduce<Record<string, EnhancedDocument>>((acc, doc) => {
	  acc[doc.id] = { ...doc, isPlaying: false, playbackSpeed: "1" };
	  return acc;
	}, {}),
	categories: catsResp.data.reduce<Record<string, Category>>((acc, cat) => {
	  acc[cat.id] = cat;
	  return acc;
	}, {})
      };
    } catch (err) {
      return rejectWithValue("Error retrieving document info!");
    }
  }
);

interface UpdateBookmarkProps {
  docId: string;
  time?: number;
  page?: number;
  bookmarkId?: number | string;
}
const BookmarkOrErrSchema = z.union([BookmarkSchema, ErrSchema]);
/** An async thunk that handles a lot of work surrounding bookmarks and page-resumption.
 *
 * @param docId - required; which document to do bookmark things on. Returns an error if the document does not exist.
 * @param time - optional; the time to set/update the bookmark to in seconds. Defaults to zero.
 * @param page - optional; the zero-indexed page to set/update the bookmark to. Defaults to zero.
 * @param bookmarkId - optional; either a bookmarkId or the relative index of a bookmark. If omitted or if it points to a nonexistant bookmark, the field is ignored and a new bookmark is created.
 * @returns a new `Bookmark`
 */
export const upsertBookmark = createAsyncThunk<
  Bookmark,
  UpdateBookmarkProps,
  { rejectValue: string, state: RootState }
>(
  'data/upsertBookmark',
  async ({ docId, time, page, bookmarkId }, { rejectWithValue, getState }) => {
    const state = getState();
    if (state.categories.status === "success") {
      const doc = state.categories.documents[docId];
      if (doc === undefined) {
	return rejectWithValue("No such document with that id exists!");
      } else {
	let bookmark: Bookmark | undefined = undefined;
	if (bookmarkId === undefined) {
	  bookmark = doc.bookmarks.at(0);
	} else if (typeof bookmarkId === "string") {
	  bookmark = doc.bookmarks.find(b => b.id === bookmarkId);
	} else if (typeof bookmarkId === "number") {
	  bookmark = doc.bookmarks.at(bookmarkId);
	}
	
	const slug = bookmark === undefined ? "" : `/${bookmark.id}`;
	const req = await fetch(`/api/v1/docs/${docId}/bookmarks${slug}`, {
	  method: bookmark === undefined ? "POST" : "PATCH",
	  headers: {
	    'Content-Type': 'application/json',
	  },
	  body: JSON.stringify({
	    // Pass the full infinite chaos of user input to the server...
	    page: page ?? bookmark?.page ?? 0,
	    audiotime: time ?? bookmark?.audiotime ?? 0
	  })
	});

	// ... and let the server decide if that change is a good idea or not
	const resp = BookmarkOrErrSchema.safeParse(await req.json());
	if (resp.success) {
	  if ("err" in resp.data) {
	    return rejectWithValue(resp.data.err);
	  } else {
	    return resp.data;
	  }
	} else {
	  return rejectWithValue(resp.error.message);
	}	
      }
    } else {
      return rejectWithValue("Can't set the playback position while categories are still pending!")
    }
  }
);

interface UpdateDocumentProps {
  docId: string;
  name?: string;
  categoryId?: string;
  order?: number;
}
const DocumentOrErrSchema = z.union([DocumentSchema, ErrSchema]);

/** An async thunk for modifying document properties
 *
 * @param docId - required; which document to modify. Returns an error if the document does not exist.
 * @param name - optional; the new name for the document.
 * @param categoryId - optional; the new category for the document. Rejects if the category does not exist
 * @param order - optional; a new index for the document in its current, or new, category. Rejects if out of bounds.
 * @returns a new `Document`
 */
export const updateDocument = createAsyncThunk<
  Document,
  UpdateDocumentProps,
  { rejectValue: string }
>(
  'data/updateDocument',
  async ({ docId, name, categoryId, order }, { rejectWithValue }) => {
    const req = await fetch(`/api/v1/docs/${docId}`, {
      method: "PATCH",
      headers: {
	'Content-Type': 'application/json',
      },
      // The server is the ultimate arbiter of what changes are allowed and which changes aren't
      body: JSON.stringify({
	name,
	categoryId,
	order
      })
    });
    const res = DocumentOrErrSchema.safeParse(await req.json());
    if (res.success) {
      if ("err" in res.data) {
	return rejectWithValue(res.data.err);
      } else {
	return res.data;
      }
    } else {
      return rejectWithValue(res.error.message);
    }
  }
);


interface CreateDocumentProps {
  file: File;
  name?: string;
  categoryId?: string;
  order?: number
}
/** An async thunk for creating a new Document
 *
 * @param file - required; the backing PDF to send to the server
 * @param name - optional; the new name for the document. Defaults to the file name
 * @param categoryId - optional; the category to put the document in. Defaults to either the first category based on `order`.
 * @param order - optional; a new index for the document in the appropriate category. Rejects if out of bounds.
 * @returns a new `Document`
 */
export const createDocument = createAsyncThunk<
  EnhancedDocument,
  CreateDocumentProps,
  { rejectValue: string, state: RootState }
>(
  'data/createDocument',
  async ({ file: _1, name: _2, categoryId: _3, order: _4 }, { rejectWithValue, getState }) => {
    const state = getState();
    if (state.categories.status === "success") {
      return {
	id: "NOT-A-NANOID",
	name: 'Bee Movie',
	numpages: 1, 
	completed: true,
	s3key: 'ec05b36a4a68b40d3b4f8195907d2a64201672fd14d96a4502c679813288bcb8',
	bookmarks: [
	  {
	    id: "NOT-A-NANOID-BOOKMARK",
	    page: 0,
            audiotime: 0,
            order: 0,
	    documentId: "NOT-A-NANOID"
	  }
	],
	order: 0,
	isPlaying: false,
	playbackSpeed: "1",
	categoryId: Object.keys(state.categories.categories)[0]
      }
    } else {
      return rejectWithValue("Cannot create a document while the documents list is still pending!");
    }
    
    /*
    const state = getState();
    if (name === undefined) {
      name = file.name.replace(/\.pdf$/, "");
    }
    if (categoryId === undefined) {
      if (state.categories.status === "success") {
	categoryId = Object.values(state.categories.categories).find(c => c?.order === 0)?.id;
      }
    }

    const req = await fetch(`/api/v1/docs`, {
      method: "POST",
      headers: {
	'Content-Type': 'application/json',
      },
      // The server is the ultimate arbiter of what changes are allowed and which changes aren't
      body: JSON.stringify({
	name,
	categoryId,
	order
      })
    });
    const res = DocumentOrErrSchema.safeParse(await req.json());
    if (res.success) {
      if ("err" in res.data) {
	return rejectWithValue(res.data.err);
      } else {
	return res.data;
      }
    } else {
      return rejectWithValue(res.error.message);
    }
    */
  }
);

interface UpsertCategoryProps {
  categoryId?: string,
  name?: string,
  color?: string,
  order?: number
}

const CategoryOrErrSchema = z.union([CategorySchema, ErrSchema]);
/** An async thunk for modifying categories
 *
 * @param categoryId - optional; which Category to modify. Returns an error if the id is provided and the associated category does not exist. If omitted, a new category is created.
 * @param name - optional if updating; the new name for the category.
 * @param color - optional if updating; the new color for the category.
 * @param order - optional; which index to store the category at. Rejects if out of bounds.
 * @returns a new `Category`
 */
export const upsertCategory = createAsyncThunk<
  Category,
  UpsertCategoryProps,
  { rejectValue: string }
>(
  'data/upsertCategory',
  async ({ categoryId, name, color, order }, { rejectWithValue }) => {
    const slug = categoryId === undefined ? "" : `/${categoryId}`;
    const req = await fetch(`/api/v1/categories${slug}`, {
      method: categoryId === undefined ? "POST" : "PATCH",
      headers: {
	'Content-Type': 'application/json',
      },
      body: JSON.stringify({
	name,
	color,
	order
      })
    });
    const res = CategoryOrErrSchema.safeParse(await req.json());
    if (res.success) {
      if ("err" in res.data) {
	return rejectWithValue(res.data.err);
      } else {
	return res.data;
      }
    } else {
      return rejectWithValue(res.error.message);
    }
  }
);

/** An async thunk for deleting categories
 *
 * @param id - required; which Category to delete.
 * @returns void
 */
export const deleteCategory = createAsyncThunk<
  string,
  { id: string },
  { rejectValue: string }
>(
  'data/deleteCategory',
  async ({ id }, { rejectWithValue }) => {
    const req = await fetch(`/api/v1/categories/${id}`, {
      method: "DELETE"
    });
    if (req.status !== 204) {
      const res = ErrSchema.safeParse(await req.json());
      if (res.success) {
	return rejectWithValue(res.data.err);
      } else {
	return rejectWithValue(res.error.message);
      }
    } else {
      return id;
    }
  }
);

/** An async thunk for deleting documents
 *
 * @param id - required; which Document to delete.
 * @returns void
 */
export const deleteDocument = createAsyncThunk<
  string,
  { id: string },
  { rejectValue: string }
>(
  'data/deleteDocument',
  async ({ id }, { rejectWithValue }) => {
    const req = await fetch(`/api/v1/docs/${id}`, {
      method: "DELETE"
    });
    if (req.status !== 204) {
      const res = ErrSchema.safeParse(await req.json());
      if (res.success) {
	return rejectWithValue(res.data.err);
      } else {
	return rejectWithValue(res.error.message);
      }
    } else {
      return id;
    }
  }
);

export const selectCategories = createSelector(
  [(state: RootState) => state.categories],
  (categoriesState) => {
    if (categoriesState.status !== 'success') return {};

    const { categories, documents } = categoriesState;

    return Object.values(categories).reduce<Record<string, Category & { documents: EnhancedDocument[] }>>(
      (acc, category) => {
        if (category) {
          const relatedDocuments = Object.values(documents).filter(
            (doc): doc is EnhancedDocument => doc?.categoryId === category.id
          );

          acc[category.id] = { ...category, documents: relatedDocuments };
        }
        return acc;
      },
      {}
    );
  }
);

export const { setPlaybackSpeed, setIsPlaying } = categoriesSlice.actions;

export default categoriesSlice.reducer;


```
File: /Users/tarioyou/ListenInk/frontend/src/store/slices/ui.ts
Content:```
import { createSlice } from '@reduxjs/toolkit';
import type { PayloadAction } from '@reduxjs/toolkit';

export type PDFDropStatus = "neutral" | "hover" | "drop-success" | "drop-failure";

interface UIState {
  sidebarOpen: boolean;
  pdfDropModalOpen: boolean;
  pdfDropModalStatus: PDFDropStatus;
  openCategories: Record<string, boolean | undefined>; // Sets would be fun, but aren't JSON serializable
  searchDialogOpen: boolean;
  searchQuery: string;
}

interface CategoryOpen {
  open: boolean,
  id: string
}

const initialState: UIState = {
  sidebarOpen: true,
  pdfDropModalOpen: false,
  pdfDropModalStatus: "neutral",
  openCategories: {},
  searchDialogOpen: false,
  searchQuery: ""
}

export const uiSlice = createSlice({
  name: 'ui',
  initialState,
  reducers: {
    setSidebar: (state, action: PayloadAction<boolean>) => {
      state.sidebarOpen = action.payload;
    },

    setCategory: (state, action: PayloadAction<CategoryOpen>) => {
      state.openCategories[action.payload.id] = action.payload.open;
    },

    setQuery: (state, action: PayloadAction<string>) => {
      state.searchQuery = action.payload;
    },

    setSearchDialog: (state, action: PayloadAction<boolean>) => {
      state.searchDialogOpen = action.payload;
    },

    setPdfDropModal: (state, action: PayloadAction<boolean>) => {
      state.pdfDropModalOpen = action.payload;
    },

    setPdfDropStatus: (state, action: PayloadAction<PDFDropStatus>) => {
      state.pdfDropModalStatus = action.payload;
    }
  },
})

export const {
  setSidebar,
  setCategory,
  setQuery,
  setSearchDialog,
  setPdfDropModal,
  setPdfDropStatus
} = uiSlice.actions
export default uiSlice.reducer


```
File: /Users/tarioyou/ListenInk/frontend/src/store/slices/auth.ts
Content:```
// frontend/src/store/slices/auth.ts
import { z } from "zod";
import { createSlice, createAsyncThunk, PayloadAction } from "@reduxjs/toolkit";
import { User, UserSchema, ErrSchema } from "@/types";
import { PromiseState } from "../helper-types";

type AuthState = PromiseState<User>;

const initialState = { status: "pending" } as AuthState;

export const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchProfile.pending, (state: AuthState) => {
        state.status = "pending";
      })
      .addCase(fetchProfile.fulfilled, (_, action: PayloadAction<User>) => {
        return {
          status: "success",
          ...action.payload,
        };
      })
      .addCase(
        fetchProfile.rejected,
        (_, action: PayloadAction<string | undefined>) => {
          return {
            status: "failure",
            message: action.payload ?? "An unknown error occured!",
          };
        }
      );
  },
});

const UserOrErrSchema = z.union([UserSchema, ErrSchema]);
export const fetchProfile = createAsyncThunk<
  User,
  void,
  { rejectValue: string }
>("data/fetchCreds", async (_, { rejectWithValue }) => {
  try {
    const hasCookie = document.cookie.includes("userId");
    const req = await fetch("/api/v1/auth", {
      method: hasCookie ? "GET" : "POST",
    });
    const resp = UserOrErrSchema.safeParse(await req.json());

    if (resp.success) {
      if ("err" in resp.data) {
        console.warn("[AUTH] Session expired. Attempting re-authentication.");
        document.cookie =
          "userId=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;"; // Clear invalid cookies
        return await reAuthenticate();
      } else {
        return resp.data;
      }
    } else {
      console.error(resp.error.message);
      return rejectWithValue("Could not parse user profile info!");
    }
  } catch (err) {
    console.error(err);
    return rejectWithValue("Error retrieving user profile info!");
  }
});

async function reAuthenticate(): Promise<User> {
  const req = await fetch("/api/v1/auth", { method: "POST" }); // Force a new session
  const resp = UserOrErrSchema.safeParse(await req.json());

  if (resp.success) {
    if ("err" in resp.data) {
      throw new Error("[AUTH] Failed to re-authenticate: " + resp.data.err);
    } else {
      console.log("[AUTH] Successfully re-authenticated.");
      return resp.data;
    }
  } else {
    throw new Error("[AUTH] Re-authentication failed.");
  }
}

export default authSlice.reducer;


```

=== Summary ===
Total files processed: 47
Total tokens across all files: 33878
Average tokens per file: 720.81
